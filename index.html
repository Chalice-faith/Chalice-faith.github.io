<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chalice-faith.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Chalice 的技术博客">
<meta property="og:url" content="https://chalice-faith.github.io/index.html">
<meta property="og:site_name" content="Chalice 的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chalice">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chalice-faith.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chalice 的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chalice 的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chalice-faith.github.io/2025/10/08/Epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/08/Epoll/" class="post-title-link" itemprop="url">Epoll</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-08 14:43:17 / 修改时间：15:00:05" itemprop="dateCreated datePublished" datetime="2025-10-08T14:43:17+08:00">2025-10-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="EPOLL"><a href="#EPOLL" class="headerlink" title="EPOLL"></a>EPOLL</h1><p>本章主要简述epoll的基础理论知识。</p>
<h3 id="流？I-O操作-阻塞"><a href="#流？I-O操作-阻塞" class="headerlink" title="流？I&#x2F;O操作&#x2F;阻塞"></a>流？I&#x2F;O操作&#x2F;阻塞</h3><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><ul>
<li>可以进行I&#x2F;O操作的内核对象</li>
<li>文件、管道、套接字……</li>
<li>流的入口：文件描述符(fd)</li>
</ul>
<h4 id="I-O操作"><a href="#I-O操作" class="headerlink" title="I&#x2F;O操作"></a>I&#x2F;O操作</h4><p><img src="/.com//1648521298617-bac69f76-588a-4aff-a339-0242a13c145b.webp" alt="io操作01.png"></p>
<p><img src="/.com//1648521309371-806722a5-fc1a-4600-a0bb-537d325ae85d.webp" alt="io操作02.png"></p>
<p>所有对流的读写操作，我们都可以称之为IO操作。</p>
<p><em>那么当一个流中再没有数据，read的时候，或者说在流中已经写满了数据，再write，我们的IO操作就会出现一种现象，就是阻塞现象。</em></p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p><img src="/.com//1648521347097-ddeb642c-149f-451a-9978-8378066d31b3.webp" alt="阻塞01.png"></p>
<p><img src="/.com//1648521352950-297d5efa-50ca-4eba-9ee0-157ba295bbef.webp" alt="阻塞02.png"></p>
<ul>
<li>阻塞等待</li>
</ul>
<p>空出大脑可以安心睡觉。（不占用CPU宝贵的时间片）</p>
<ul>
<li>非阻塞，忙轮询</li>
</ul>
<p>浪费时间，浪费电话费，占用快递员时间（占用CPU，系统资源）</p>
<h3 id="解决阻塞死等待的办法"><a href="#解决阻塞死等待的办法" class="headerlink" title="解决阻塞死等待的办法"></a>解决阻塞死等待的办法</h3><h4 id="阻塞死等待的缺点"><a href="#阻塞死等待的缺点" class="headerlink" title="阻塞死等待的缺点"></a>阻塞死等待的缺点</h4><p><img src="/.com//1648788062409-833f5a1b-b2ff-4a7e-ac6e-b6eccf80e60e.webp" alt="解决阻塞01.png"></p>
<h4 id="办法一：非阻塞、忙轮询"><a href="#办法一：非阻塞、忙轮询" class="headerlink" title="办法一：非阻塞、忙轮询"></a>办法一：非阻塞、忙轮询</h4><p><img src="/.com//1648787955604-05973307-06e1-4418-a945-4ac6e6d752a5.webp" alt="解决阻塞02.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i in 流[] &#123;</span><br><span class="line">        <span class="keyword">if</span> i has 数据 &#123;</span><br><span class="line">            读 或者 其他处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="办法二：select"><a href="#办法二：select" class="headerlink" title="办法二：select"></a>办法二：select</h4><p><img src="/.com//1648787982672-9da9b79d-96b1-46e7-9059-82bcc429977a.webp" alt="解决阻塞03.png"></p>
<h4 id="办法三：epoll"><a href="#办法三：epoll" class="headerlink" title="办法三：epoll"></a>办法三：epoll</h4><p><img src="/.com//1648788092230-e19de60d-27b5-4b3d-a1ba-c26f1546b884.webp" alt="解决阻塞04.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while <span class="literal">true</span> &#123;</span><br><span class="line">    可处理的流[] = epoll_wait(epoll_fd);  <span class="comment">//阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in 可处理的流[] &#123;</span><br><span class="line">        读 或者 其他处理</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是epoll"><a href="#什么是epoll" class="headerlink" title="什么是epoll"></a>什么是epoll</h3><ul>
<li><p>与select，poll一样，对I&#x2F;O多路复用的技术</p>
</li>
<li><p>只关心“活跃”的链接，无需遍历全部描述符集合</p>
</li>
<li><p>能够处理大量的链接请求(系统可以打开的文件数目)</p>
</li>
</ul>
<h3 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h3><h4 id="创建EPOLL"><a href="#创建EPOLL" class="headerlink" title="创建EPOLL"></a>创建EPOLL</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param size 告诉内核监听的数目</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @returns 返回一个epoll句柄（即一个文件描述符）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/.com//1648788201363-5356645b-0116-4c7d-8477-de2535c47e4b.webp" alt="epoll-api01.png"></p>
<h4 id="控制EPOLL"><a href="#控制EPOLL" class="headerlink" title="控制EPOLL"></a>控制EPOLL</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param epfd 用epoll_create所创建的epoll句柄</span></span><br><span class="line"><span class="comment"> * @param op 表示对epoll监控描述符控制的动作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * EPOLL_CTL_ADD(注册新的fd到epfd)</span></span><br><span class="line"><span class="comment"> * EPOLL_CTL_MOD(修改已经注册的fd的监听事件)</span></span><br><span class="line"><span class="comment"> * EPOLL_CTL_DEL(epfd删除一个fd)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 需要监听的文件描述符</span></span><br><span class="line"><span class="comment"> * @param event 告诉内核需要监听的事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @returns 成功返回0，失败返回-1, errno查看错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, </span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"> <span class="type">__uint32_t</span> events; <span class="comment">/* epoll 事件 */</span></span><br><span class="line"> <span class="type">epoll_data_t</span> data; <span class="comment">/* 用户传递的数据 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * events : &#123;EPOLLIN, EPOLLOUT, EPOLLPRI, </span></span><br><span class="line"><span class="comment">            EPOLLHUP, EPOLLET, EPOLLONESHOT&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">new_event</span>;</span></span><br><span class="line"></span><br><span class="line">new_event.events = EPOLLIN | EPOLLOUT;</span><br><span class="line">new_event.data.fd = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, <span class="number">5</span>, &amp;new_event);</span><br></pre></td></tr></table></figure>

<p><img src="/.com//1648788239338-54127006-2e32-49ea-adca-5cbffcb0cec0.webp" alt="epoll-api02.png"></p>
<h4 id="等待EPOLL"><a href="#等待EPOLL" class="headerlink" title="等待EPOLL"></a>等待EPOLL</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param epfd 用epoll_create所创建的epoll句柄</span></span><br><span class="line"><span class="comment"> * @param event 从内核得到的事件集合</span></span><br><span class="line"><span class="comment"> * @param maxevents 告知内核这个events有多大,</span></span><br><span class="line"><span class="comment"> *             注意: 值 不能大于创建epoll_create()时的size.</span></span><br><span class="line"><span class="comment"> * @param timeout 超时时间</span></span><br><span class="line"><span class="comment"> *     -1: 永久阻塞</span></span><br><span class="line"><span class="comment"> *     0: 立即返回，非阻塞</span></span><br><span class="line"><span class="comment"> *     &gt;0: 指定微秒</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @returns 成功: 有多少文件描述符就绪,时间到时返回0</span></span><br><span class="line"><span class="comment"> *          失败: -1, errno 查看错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *event, </span></span><br><span class="line"><span class="params">            <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">my_event</span>[1000];</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> event_cnt = epoll_wait(epfd, my_event, <span class="number">1000</span>, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/.com//1648788251180-ad757c0a-2f90-48aa-8292-e5417e646cc6.webp" alt="epoll-api03.png"></p>
<h4 id="epoll编程框架"><a href="#epoll编程框架" class="headerlink" title="epoll编程框架"></a>epoll编程框架</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 epoll</span></span><br><span class="line"><span class="type">int</span> epfd = epoll_crete(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 listen_fd 添加进 epoll 中</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd,&amp;listen_event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//阻塞等待 epoll 中 的fd 触发</span></span><br><span class="line">    <span class="type">int</span> active_cnt = epoll_wait(epfd, events, <span class="number">1000</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; active_cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (evnets[i].data.fd == listen_fd) &#123;</span><br><span class="line">            <span class="comment">//accept. 并且将新accept 的fd 加进epoll中.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="comment">//对此fd 进行读操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">            <span class="comment">//对此fd 进行写操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="触发模式"><a href="#触发模式" class="headerlink" title="触发模式"></a>触发模式</h3><h4 id="水平触发"><a href="#水平触发" class="headerlink" title="水平触发"></a>水平触发</h4><p><img src="/.com//1648788347586-9527ebd4-c109-47e0-85c3-918876732978.webp" alt="epoll触发模式01.png"></p>
<p><img src="/.com//1648788353383-5511612c-4222-48a1-84b7-f40ca19dc9ae.webp" alt="epoll触发模式02.png"></p>
<p>水平触发的主要特点是，如果用户在监听epoll事件，当内核有事件的时候，会拷贝给用户态事件，但是如果用户只处理了一次，那么剩下没有处理的会在下一次epoll_wait再次返回该事件。</p>
<p>这样如果用户永远不处理这个事件，就导致每次都会有该事件从内核到用户的拷贝，耗费性能，但是水平触发相对安全，最起码事件不会丢掉，除非用户处理完毕。</p>
<h4 id="边缘触发"><a href="#边缘触发" class="headerlink" title="边缘触发"></a>边缘触发</h4><p><img src="/.com//1648788358769-07598731-7810-46f2-8059-e1828386f5f9.webp" alt="epoll触发模式03.png"></p>
<p><img src="/.com//1648788363448-f6531659-91b0-4657-aacc-857370736546.webp" alt="epoll触发模式04.png"></p>
<p>边缘触发，相对跟水平触发相反，当内核有事件到达， 只会通知用户一次，至于用户处理还是不处理，以后将不会再通知。这样减少了拷贝过程，增加了性能，但是相对来说，如果用户马虎忘记处理，将会产生事件丢的情况。</p>
<h3 id="epoll服务器示例-c语言实现"><a href="#epoll服务器示例-c语言实现" class="headerlink" title="epoll服务器示例(c语言实现)"></a>epoll服务器示例(c语言实现)</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT         (7778)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL_MAX_NUM       (2048)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_MAX_LEN      (4096)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[BUFFER_MAX_LEN];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_toupper</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i ++) &#123;</span><br><span class="line">        str[i] = <span class="built_in">toupper</span>(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> client_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span>           client_len;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> epfd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>, *<span class="title">my_events</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll create</span></span><br><span class="line">    epfd = epoll_create(EPOLL_MAX_NUM);</span><br><span class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll create&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen_fd -&gt; epoll</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = listen_fd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &amp;event) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll ctl add listen_fd &quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_events = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event) * EPOLL_MAX_NUM);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// epoll wait</span></span><br><span class="line">        <span class="type">int</span> active_fds_cnt = epoll_wait(epfd, my_events, EPOLL_MAX_NUM, <span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; active_fds_cnt; i++) &#123;</span><br><span class="line">            <span class="comment">// if fd == listen_fd</span></span><br><span class="line">            <span class="keyword">if</span> (my_events[i].data.fd == listen_fd) &#123;</span><br><span class="line">                <span class="comment">//accept</span></span><br><span class="line">                client_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line">                <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> ip[<span class="number">20</span>];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;new connection[%s:%d]\n&quot;</span>, inet_ntop(AF_INET, &amp;client_addr.sin_addr, ip, <span class="keyword">sizeof</span>(ip)), ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">                event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                event.data.fd = client_fd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, client_fd, &amp;event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (my_events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;EPOLLIN\n&quot;</span>);</span><br><span class="line">                client_fd = my_events[i].data.fd;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// do read</span></span><br><span class="line"></span><br><span class="line">                buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> n = read(client_fd, buffer, <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, client_fd, &amp;event);</span><br><span class="line">                    close(client_fd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[read]: %s\n&quot;</span>, buffer);</span><br><span class="line">                    buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">                    str_toupper(buffer);</span><br><span class="line">                    write(client_fd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[write]: %s\n&quot;</span>, buffer);</span><br><span class="line">                    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_MAX_LEN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">                    event.events = EPOLLOUT;</span></span><br><span class="line"><span class="comment">                    event.data.fd = client_fd;</span></span><br><span class="line"><span class="comment">                    epoll_ctl(epfd, EPOLL_CTL_MOD, client_fd, &amp;event);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (my_events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;EPOLLOUT\n&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">                client_fd = my_events[i].data.fd;</span></span><br><span class="line"><span class="comment">                str_toupper(buffer);</span></span><br><span class="line"><span class="comment">                write(client_fd, buffer, strlen(buffer));</span></span><br><span class="line"><span class="comment">                printf(&quot;[write]: %s\n&quot;, buffer);</span></span><br><span class="line"><span class="comment">                memset(buffer, 0, BUFFER_MAX_LEN);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                event.events = EPOLLIN;</span></span><br><span class="line"><span class="comment">                event.data.fd = client_fd;</span></span><br><span class="line"><span class="comment">                epoll_ctl(epfd, EPOLL_CTL_MOD, client_fd, &amp;event);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line">    close(epfd);</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LINE (1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT (7778)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setnoblocking</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> opts = <span class="number">0</span>;</span><br><span class="line">    opts = fcntl(fd, F_GETFL);</span><br><span class="line">    opts = opts | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>  sockfd;</span><br><span class="line">    <span class="type">char</span> recvline[MAX_LINE + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage ./client &lt;SERVER_IP&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">if</span> ( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// server addr 赋值</span></span><br><span class="line">    bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;server_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;inet_pton error for %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链接服务端</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*) &amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;connect error\n&quot;</span>); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setnoblocking(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> input[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的从标准输入字符串</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(input, <span class="number">100</span>, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[send] %s\n&quot;</span>, input);</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把输入的字符串发送 到 服务器中去</span></span><br><span class="line">        n = send(sockfd, input, <span class="built_in">strlen</span>(input), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取 服务器返回的数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n = read(sockfd, recvline + count, MAX_LINE);</span><br><span class="line">            <span class="keyword">if</span> (n == MAX_LINE)</span><br><span class="line">            &#123;</span><br><span class="line">                count += n;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count += n;</span><br><span class="line">                recvline[count] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[recv] %s\n&quot;</span>, recvline);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chalice-faith.github.io/2025/10/05/Linux%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9CIO%E5%A4%8D%E7%94%A8%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/05/Linux%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9CIO%E5%A4%8D%E7%94%A8%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Linux中的网络IO复用并发模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-05 16:32:30" itemprop="dateCreated datePublished" datetime="2025-10-05T16:32:30+08:00">2025-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-08 16:00:06" itemprop="dateModified" datetime="2025-10-08T16:00:06+08:00">2025-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux网络Server的N种并发模型"><a href="#Linux网络Server的N种并发模型" class="headerlink" title="Linux网络Server的N种并发模型"></a>Linux网络Server的N种并发模型</h1><p>该博客参考了<a target="_blank" rel="noopener" href="https://www.yuque.com/aceld">刘丹冰Aceld · 语雀</a>文章与视频<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jK4y1N7ST%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%8F%97%E7%9B%8A%E5%8C%AA%E6%B5%85">https://www.bilibili.com/video/BV1jK4y1N7ST的内容，受益匪浅</a></p>
<h3 id="模型一、单线程Accept（无IO复用）"><a href="#模型一、单线程Accept（无IO复用）" class="headerlink" title="模型一、单线程Accept（无IO复用）"></a>模型一、单线程Accept（无IO复用）</h3><h4 id="1-模型结构"><a href="#1-模型结构" class="headerlink" title="(1) 模型结构"></a>(1) 模型结构</h4><p>该模型的核心逻辑如下（以 TCP 为例）：</p>
<ol>
<li>服务器创建监听套接字（listening socket），绑定端口并调用 <code>listen()</code>。</li>
<li>在一个无限循环中，调用 <code>accept()</code> 等待客户端连接。</li>
<li>每当有新连接到来，<code>accept()</code> 返回一个新的已连接套接字（connected socket）。</li>
<li><strong>在主线程中直接对该连接进行读写处理（如 recv&#x2F;send）</strong>，处理完后再回到 <code>accept()</code> 等待下一个连接。</li>
</ol>
<p>伪代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> listen_fd = <span class="built_in">socket</span>(...);</span><br><span class="line"><span class="built_in">bind</span>(listen_fd, ...);</span><br><span class="line"><span class="built_in">listen</span>(listen_fd, ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> conn_fd = <span class="built_in">accept</span>(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  <span class="comment">// 阻塞等待连接</span></span><br><span class="line">    <span class="built_in">handle_client</span>(conn_fd);  <span class="comment">// 在主线程中处理整个会话</span></span><br><span class="line">    <span class="built_in">close</span>(conn_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//1651593761496-d6687f19-63c7-4429-9fd5-171acd3ad7f0.webp" alt="158-并发模型1.jpeg"></p>
<h4 id="2-模型分析"><a href="#2-模型分析" class="headerlink" title="(2) 模型分析"></a>(2) 模型分析</h4><p>① 主线程<code>main thread</code>执行阻塞Accept，每次客户端Connect链接过来，<code>main thread</code>中accept响应并建立连接</p>
<p>② 创建链接成功，得到<code>Connfd1</code>套接字后, 依然在<code>main thread</code>串行处理套接字读写，并处理业务。</p>
<p>③ 在②处理业务中，如果有新客户端<code>Connect</code>过来，<code>Server</code>无响应，直到当前套接字全部业务处理完毕。</p>
<p>④ 当前客户端处理完后，完毕链接，处理下一个客户端请求。</p>
<h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="(3) 优缺点"></a>(3) 优缺点</h4><p><strong>优点</strong>：</p>
<ul>
<li>socket编程流程清晰且简单，适合学习使用，了解socket基本编程流程。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>该模型并非并发模型，是串行的服务器，同一时刻，监听并响应最大的网络请求量为<code>1</code>。 即并发量为<code>1</code>。 </li>
<li>仅适合学习基本socket编程，不适合任何服务器Server构建</li>
</ul>
<h3 id="模型二、单线程Accept-多线程读写业务-无I-O多路复用"><a href="#模型二、单线程Accept-多线程读写业务-无I-O多路复用" class="headerlink" title="模型二、单线程Accept+多线程读写业务(无I&#x2F;O多路复用)"></a>模型二、单线程Accept+多线程读写业务(无I&#x2F;O多路复用)</h3><h4 id="1-模型结构-1"><a href="#1-模型结构-1" class="headerlink" title="(1) 模型结构"></a>(1) 模型结构</h4><p><strong>核心结构：</strong></p>
<ol>
<li><strong>主线程</strong>：只负责监听和接受新连接（调用 <code>accept()</code>）。</li>
<li><strong>工作线程</strong>：每当有新连接到来，主线程创建一个新线程（或从线程池中分配），由该线程负责该连接的整个生命周期（包括 <code>recv</code>&#x2F;<code>send</code> 和业务逻辑处理）。</li>
<li><strong>无 I&#x2F;O 复用</strong>：所有 I&#x2F;O 操作（<code>accept</code>、<code>recv</code>、<code>send</code>）均为<strong>阻塞式</strong>，不使用 <code>select</code>&#x2F;<code>epoll</code> 等机制。</li>
</ol>
<p><img src="/.io//1651593783816-bd32ec9d-ab9f-4e69-a952-21f8308fdefc.webp" alt="159-并发模型2.jpeg"></p>
<h4 id="2-模型分析-1"><a href="#2-模型分析-1" class="headerlink" title="(2) 模型分析"></a>(2) 模型分析</h4><p>① 主线程<code>main thread</code>执行阻塞Accept，每次客户端Connect链接过来，<code>main thread</code>中accept响应并建立连接</p>
<p>② 创建链接成功，得到<code>Connfd1</code>套接字后，创建一个新线程<code>thread1</code>用来处理客户端的读写业务。<code>main thead</code>依然回到<code>Accept</code>阻塞等待新客户端。</p>
<p>③ <code>thread1</code>通过套接字<code>Connfd1</code>与客户端进行通信读写。</p>
<p>④ server在②处理业务中，如果有新客户端<code>Connect</code>过来，<code>main thread</code>中<code>Accept</code>依然响应并建立连接，重复②过程。</p>
<h4 id="3-优缺点-1"><a href="#3-优缺点-1" class="headerlink" title="(3) 优缺点"></a>(3) 优缺点</h4><p><strong>优点</strong>：</p>
<ul>
<li>基于<code>模型一：单线程Accept（无IO复用）</code> 支持了并发的特性。</li>
<li>使用灵活，一个客户端对应一个线程单独处理，<code>server</code>处理业务内聚程度高，客户端无论如何写，服务端均会有一个线程做资源响应。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>随着客户端的数量增多，需要开辟的线程也增加，客户端与server线程数量<code>1:1</code>正比关系，一次对于高并发场景，线程数量收到硬件上限瓶颈。</li>
<li>对于长链接，客户端一旦无业务读写，只要不关闭，server的对应线程依然需要保持连接(心跳、健康监测等机制)，占用连接资源和线程开销资源浪费。</li>
<li>仅适合客户端数量不大，并且数量可控的场景使用。</li>
</ul>
<p><em>仅适合学习基本socket编程，不适合任何服务器Server构建。</em></p>
<h3 id="模型三、单线程多路IO复用"><a href="#模型三、单线程多路IO复用" class="headerlink" title="模型三、单线程多路IO复用"></a>模型三、单线程多路IO复用</h3><h4 id="1-模型结构-2"><a href="#1-模型结构-2" class="headerlink" title="(1) 模型结构"></a>(1) 模型结构</h4><p><strong>核心逻辑：</strong></p>
<ol>
<li><p>创建监听 socket，设为非阻塞，加入事件循环。</p>
</li>
<li><p>主循环调用 <code>epoll_wait()</code>（或类似）等待事件。</p>
</li>
<li><p>若监听 socket 可读 → 调用 <code>accept()</code> 接受新连接，设为非阻塞，加入事件集。</p>
</li>
<li><p>若某客户端 socket 可读 → 调用 <code>recv()</code> 读取数据（非阻塞），处理业务。</p>
</li>
<li><p>若需响应 → 将 socket 加入可写事件，待可写时 <code>send()</code>。</p>
</li>
<li><p>连接关闭时从事件集中移除。</p>
<p><img src="/.io//1651593799111-2612c72a-c794-4c57-b668-5355fcf50be3.webp" alt="160-并发模型3.jpeg"></p>
</li>
</ol>
<h4 id="2-模型分析-2"><a href="#2-模型分析-2" class="headerlink" title="(2) 模型分析"></a>(2) 模型分析</h4><p>① 主线程<code>main thread</code>创建<code>listenFd</code>之后，采用多路I&#x2F;O复用机制(如:select、epoll)进行IO状态阻塞监控。有<code>Client1</code>客户端<code>Connect</code>请求，I&#x2F;O复用机制检测到<code>ListenFd</code>触发读事件，则进行<code>Accept</code>建立连接，并将新生成的<code>connFd1</code>加入到<code>监听I/O集合</code>中。</p>
<p>② <code>Client1</code>再次进行正常读写业务请求，<code>main thread</code>的<code>多路I/O复用机制</code>阻塞返回，会触该套接字的读&#x2F;写事件等。</p>
<p>③ 对于<code>Client1</code>的读写业务，Server依然在<code>main thread</code>执行流程提继续执行，此时如果有新的客户端<code>Connect</code>链接请求过来，Server将没有即时响应。</p>
<p>④ 等到Server处理完一个连接的<code>Read+Write</code>操作，继续回到<code>多路I/O复用机制</code>阻塞，其他链接过来重复   ②、③流程。</p>
<h4 id="3-优缺点-2"><a href="#3-优缺点-2" class="headerlink" title="(3) 优缺点"></a>(3) 优缺点</h4><p><strong>优点</strong>：</p>
<ul>
<li>单流程解决了可以同时监听多个客户端读写状态的模型，不需要<code>1:1</code>与客户端的线程数量关系。</li>
<li>多路I&#x2F;O复用阻塞，非忙询状态，不浪费CPU资源， CPU利用率较高。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>虽然可以监听多个客户端的读写状态，但是同一时间内，只能处理一个客户端的读写操作，实际上读写的业务并发为1。</li>
<li>多客户端访问Server，业务为串行执行，大量请求会有排队延迟现象，如图中⑤所示，当<code>Client3</code>占据<code>main thread</code>流程时，<code>Client1,Client2</code>流程卡在<code>IO复用</code>等待下次监听触发事件。</li>
</ul>
<h3 id="模型四、单线程多路IO复用-多线程读写业务-业务工作池"><a href="#模型四、单线程多路IO复用-多线程读写业务-业务工作池" class="headerlink" title="模型四、单线程多路IO复用+多线程读写业务(业务工作池)"></a>模型四、单线程多路IO复用+多线程读写业务(业务工作池)</h3><h4 id="1-模型结构-3"><a href="#1-模型结构-3" class="headerlink" title="(1) 模型结构"></a>(1) 模型结构</h4><p><img src="/.io//1651593821792-89521ed3-0746-44da-9a87-167caa946018.webp" alt="161-并发模型4.jpeg"></p>
<h4 id="2-模型分析-3"><a href="#2-模型分析-3" class="headerlink" title="(2) 模型分析"></a>(2) 模型分析</h4><p>① 主线程<code>main thread</code>创建<code>listenFd</code>之后，采用多路I&#x2F;O复用机制(如:select、epoll)进行IO状态阻塞监控。有<code>Client1</code>客户端<code>Connect</code>请求，I&#x2F;O复用机制检测到<code>ListenFd</code>触发读事件，则进行<code>Accept</code>建立连接，并将新生成的<code>connFd1</code>加入到<code>监听I/O集合</code>中。</p>
<p>② 当<code>connFd1</code>有可读消息，触发读事件，并且进行读写消息</p>
<p>③ <code>main thread</code>按照固定的协议读取消息，并且交给<code>worker pool</code>工作线程池， 工作线程池在server启动之前就已经开启固定数量的<code>thread</code>，里面的线程只处理消息业务，不进行套接字读写操作。</p>
<p>④ 工作池处理完业务，触发<code>connFd1</code>写事件，将回执客户端的消息通过<code>main thead</code>写给对方。</p>
<h4 id="3-优缺点-3"><a href="#3-优缺点-3" class="headerlink" title="(3) 优缺点"></a>(3) 优缺点</h4><p><strong>优点</strong>：</p>
<ul>
<li>对于<code>模型三</code>, 将业务处理部分，通过工作池分离出来，减少多客户端访问Server，业务为串行执行，大量请求会有排队延迟时间。</li>
<li>实际上读写的业务并发为1，但是业务流程并发为worker pool线程数量，加快了业务处理并行效率。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>读写依然为<code>main thread</code>单独处理，最高读写并行通道依然为1.</li>
<li>虽然多个worker线程处理业务，但是最后返回给客户端，依旧需要排队，因为出口还是<code>main thread</code>的<code>Read + Write</code></li>
</ul>
<h3 id="模型五、单线程IO复用-多线程IO复用-链接线程池"><a href="#模型五、单线程IO复用-多线程IO复用-链接线程池" class="headerlink" title="模型五、单线程IO复用+多线程IO复用(链接线程池)"></a>模型五、单线程IO复用+多线程IO复用(链接线程池)</h3><h4 id="1-模型结构-4"><a href="#1-模型结构-4" class="headerlink" title="(1) 模型结构"></a>(1) 模型结构</h4><p><strong>核心逻辑：</strong></p>
<ol>
<li>主线程创建监听 socket，加入自己的 epoll（或直接阻塞 accept）。</li>
<li>启动 N 个工作线程，每个线程创建自己的 epoll 实例。</li>
<li>主线程 <code>accept()</code> 到新连接后，<strong>将该连接的 fd 通过管道&#x2F;消息队列传递给某个工作线程</strong>。</li>
<li>工作线程收到 fd 后，将其加入自己的 epoll，后续所有 I&#x2F;O 在该线程完成。</li>
<li>业务逻辑可在 I&#x2F;O 线程中同步执行（如 Redis），或再提交到业务线程池</li>
</ol>
<p><img src="/.io//1651593840154-1bca60e9-2440-44b3-a22a-1f11eb126ce9.webp" alt="162-并发模型5.jpeg"></p>
<p>模拟代码(go实现)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, listener net.Listener)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Worker %d started\n&quot;</span>, id)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Worker %d accept error: %v&quot;</span>, id, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 在本 goroutine 中处理整个连接（I/O + 业务）</span></span><br><span class="line">		<span class="keyword">go</span> handleConnection(conn) <span class="comment">// 或直接 handle（若业务轻量）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	reader := bufio.NewReader(conn)</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := reader.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		conn.Write(buf[:n]) <span class="comment">// echo</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">	numWorkers := <span class="number">4</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numWorkers; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			worker(id, listener)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Multi-Reactor Go server on :8080&quot;</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-模型分析-4"><a href="#2-模型分析-4" class="headerlink" title="(2) 模型分析"></a>(2) 模型分析</h4><p>① Server在启动监听之前，开辟固定数量(N)的线程，用<code>Thead Pool</code>线程池管理</p>
<p>② 主线程<code>main thread</code>创建<code>listenFd</code>之后，采用多路I&#x2F;O复用机制(如:select、epoll)进行IO状态阻塞监控。有<code>Client1</code>客户端<code>Connect</code>请求，I&#x2F;O复用机制检测到<code>ListenFd</code>触发读事件，则进行<code>Accept</code>建立连接，并将新生成的<code>connFd1</code>分发给<code>Thread Pool</code>中的某个线程进行监听。</p>
<p>③ <code>Thread Pool</code>中的每个<code>thread</code>都启动<code>多路I/O复用机制(select、epoll)</code>,用来监听<code>main thread</code>建立成功并且分发下来的socket套接字。</p>
<p>④ 如图， <code>thread</code>监听<code>ConnFd1、ConnFd2</code>, <code>thread2</code>监听<code>ConnFd3</code>,<code>thread3</code>监听<code>ConnFd4</code>. 当对应的<code>ConnFd</code>有读写事件，对应的线程处理该套接字的读写及业务。</p>
<h4 id="3-优缺点-4"><a href="#3-优缺点-4" class="headerlink" title="(3) 优缺点"></a>(3) 优缺点</h4><p><strong>优点</strong>：</p>
<ul>
<li>将<code>main thread</code>的单流程读写，分散到多线程完成，这样增加了同一时刻的读写并行通道，并行通道数量<code>N</code>， <code>N</code>为线程池<code>Thread</code>数量。</li>
<li>server同时监听的<code>ConnFd套接字</code>数量几乎成倍增大，之前的全部监控数量取决于<code>main thread</code>的<code>多路I/O复用机制</code>的最大限制***(select 默认为1024， epoll默认与内存大小相关，约3<del>6w不等)***，所以理论单点Server最高响应并发数量为&#96;N*(3</del>6W)<code>(</code>N<code>为线程池</code>Thread&#96;数量，建议与CPU核心成比例1:1)。</li>
<li>如果良好的线程池数量和CPU核心数适配，那么可以尝试CPU核心与Thread进行绑定，从而降低CPU的切换频率，提升每个<code>Thread</code>处理合理业务的效率，降低CPU切换成本开销。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>虽然监听的并发数量提升，但是最高读写并行通道依然为<code>N</code>，而且多个身处同一个Thread的客户端，会出现读写延迟现象，实际上每个<code>Thread</code>的模型特征与<code>模型三：单线程多路IO复用</code>一致。</li>
</ul>
<h3 id="模型五-进程版-、单进程多路I-O复用-多进程多路I-O复用-进程池"><a href="#模型五-进程版-、单进程多路I-O复用-多进程多路I-O复用-进程池" class="headerlink" title="模型五(进程版)、单进程多路I&#x2F;O复用+多进程多路I&#x2F;O复用(进程池)"></a>模型五(进程版)、<strong>单进程多路I&#x2F;O复用+多进程多路I&#x2F;O复用(进程池)</strong></h3><h4 id="1-模型结构-5"><a href="#1-模型结构-5" class="headerlink" title="(1) 模型结构"></a>(1) 模型结构</h4><p><img src="/.io//1651593860312-e107f7b3-3efc-498f-85a7-53524914e0c3.webp" alt="163-并发模型6.jpeg"></p>
<h4 id="2-模型分析-5"><a href="#2-模型分析-5" class="headerlink" title="(2) 模型分析"></a>(2) 模型分析</h4><p>与<code>五、单线程IO复用+多线程IO复用(链接线程池)</code>无大差异。</p>
<p>不同处</p>
<ul>
<li>进程和线程的内存布局不同导致，<code>main process</code>(主进程)不再进行<code>Accept</code>操作，而是将<code>Accept</code>过程分散到各个<code>子进程(process)</code>中.</li>
<li>进程的特性，资源独立，所以<code>main process</code>如果Accept成功的fd，其他进程无法共享资源，所以需要各子进程自行Accept创建链接</li>
<li><code>main process</code>只是监听<code>ListenFd</code>状态，一旦触发读事件(有新连接请求). 通过一些IPC(进程间通信：如信号、共享内存、管道)等, 让各自子进程<code>Process</code>竞争<code>Accept</code>完成链接建立，并各自监听。</li>
</ul>
<h4 id="3-优缺点-5"><a href="#3-优缺点-5" class="headerlink" title="(3) 优缺点"></a>(3) 优缺点</h4><p>与<code>五、单线程IO复用+多线程IO复用(链接线程池)</code>无大差异。</p>
<p><strong>不同处:</strong></p>
<p>多进程内存资源空间占用稍微大一些</p>
<p>多进程模型安全稳定型较强，这也是因为各自进程互不干扰的特点导致。</p>
<h3 id="模型六、单线程多路I-O复用-多线程多路I-O复用-多线程"><a href="#模型六、单线程多路I-O复用-多线程多路I-O复用-多线程" class="headerlink" title="模型六、单线程多路I&#x2F;O复用+多线程多路I&#x2F;O复用+多线程"></a>模型六、<strong>单线程多路I&#x2F;O复用+多线程多路I&#x2F;O复用+多线程</strong></h3><h4 id="1-模型结构-6"><a href="#1-模型结构-6" class="headerlink" title="(1) 模型结构"></a>(1) 模型结构</h4><p><img src="/.io//1651593876692-f09acaa2-de3e-410f-8874-0bb54eb1028e.webp" alt="164-并发模型7.jpeg"></p>
<h4 id="2-模型分析-6"><a href="#2-模型分析-6" class="headerlink" title="(2) 模型分析"></a>(2) 模型分析</h4><p>① Server在启动监听之前，开辟固定数量(N)的线程，用<code>Thead Pool</code>线程池管理</p>
<p>② 主线程<code>main thread</code>创建<code>listenFd</code>之后，采用多路I&#x2F;O复用机制(如:select、epoll)进行IO状态阻塞监控。有<code>Client1</code>客户端<code>Connect</code>请求，I&#x2F;O复用机制检测到<code>ListenFd</code>触发读事件，则进行<code>Accept</code>建立连接，并将新生成的<code>connFd1</code>分发给<code>Thread Pool</code>中的某个线程进行监听。</p>
<p>③ <code>Thread Pool</code>中的每个<code>thread</code>都启动<code>多路I/O复用机制(select、epoll)</code>,用来监听<code>main thread</code>建立成功并且分发下来的socket套接字。一旦其中某个被监听的客户端套接字触发<code>I/O读写事件</code>,那么，会立刻开辟一个新线程来处理<code>I/O读写</code>业务。</p>
<p>④ 但某个读写线程完成当前读写业务，如果当前套接字没有被关闭，那么将当前客户端套接字<code>如:ConnFd3</code>重新加回线程池的监控线程中，同时自身线程自我销毁。</p>
<h4 id="3-优缺点-6"><a href="#3-优缺点-6" class="headerlink" title="(3) 优缺点"></a>(3) 优缺点</h4><p><strong>优点</strong>：</p>
<ul>
<li>在<code>模型五、单线程IO复用+多线程IO复用(链接线程池)</code>基础上，除了能够保证同时响应的<code>最高并发数</code>，又能解决<code>读写并行通道</code>局限的问题。 </li>
<li>同一时刻的读写并行通道，达到<code>最大化极限</code>，一个客户端可以对应一个单独执行流程处理读写业务，读写并行通道与客户端数量<code>1:1</code>关系。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>该模型过于理想化，因为要求CPU核心数量足够大。</li>
<li>如果硬件CPU数量可数(目前的硬件情况)，那么该模型将造成大量的CPU切换成本浪费。因为为了保证读写并行通道与客户端<code>1:1</code>的关系，那么Server需要开辟的<code>Thread</code>数量就与客户端一致，那么线程池中做<code>多路I/O复用</code>的监听线程池绑定CPU数量将变得毫无意义。</li>
<li>如果每个临时的读写<code>Thread</code>都能够绑定一个单独的CPU，那么此模型将是最优模型。但是目前CPU的数量无法与客户端的数量达到一个量级，目前甚至差的不是几个量级的事。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上，我们整理了7中Server的服务器处理结构模型，每个模型都有各自的特点和优势，那么对于多少应付高并发和高CPU利用率的模型，目前多数采用的是模型五(或模型五进程版，如Nginx就是类似模型五进程版的改版)。</p>
<p>至于并发模型并非设计的约复杂越好，也不是线程开辟的越多越好，我们要考虑硬件的利用与和切换成本的开销。模型六设计就极为复杂，线程较多，但以当今的硬件能力无法支撑，反倒导致该模型性能极差。所以对于不同的业务场景也要选择适合的模型构建，并不是一定固定就要使用某个来应用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chalice-faith.github.io/2025/10/04/Golang%E5%AE%9E%E6%88%98-IMSystem1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/04/Golang%E5%AE%9E%E6%88%98-IMSystem1/" class="post-title-link" itemprop="url">Golang实战-IMSystem1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-04 22:27:40" itemprop="dateCreated datePublished" datetime="2025-10-04T22:27:40+08:00">2025-10-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chalice-faith.github.io/2025/10/04/Golang%E9%AB%98%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/04/Golang%E9%AB%98%E9%98%B6/" class="post-title-link" itemprop="url">Golang高阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-04 22:26:59" itemprop="dateCreated datePublished" datetime="2025-10-04T22:26:59+08:00">2025-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-05 21:02:51" itemprop="dateModified" datetime="2025-10-05T21:02:51+08:00">2025-10-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h2><h4 id="什么是Go-Modules"><a href="#什么是Go-Modules" class="headerlink" title="什么是Go Modules?"></a>什么是Go Modules?</h4><p>Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 推荐在生产上使用。</p>
<p>Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：</p>
<ol>
<li>Go 语言长久以来的依赖管理问题。</li>
<li>“淘汰”现有的 GOPATH 的使用模式。</li>
<li>统一社区中的其它的依赖管理工具（提供迁移功能）。</li>
</ol>
<h4 id="GOPATH的工作模式"><a href="#GOPATH的工作模式" class="headerlink" title="GOPATH的工作模式"></a>GOPATH的工作模式</h4><p>Go Modoules的目的之一就是淘汰GOPATH,  那么GOPATH是个什么?</p>
<p>为什么在 Go1.11 前就使用 GOPATH，而 Go1.11 后就开始逐步建议使用 Go modules，不再推荐 GOPATH 的模式了呢？</p>
<p><strong>What is GOPATH?</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env</span><br><span class="line"></span><br><span class="line">GOPATH=<span class="string">&quot;/home/itheima/go&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们输入<code>go env</code>命令行后可以查看到 GOPATH 变量的结果，我们进入到该目录下进行查看，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── github.com</span><br><span class="line">    ├── golang.org</span><br><span class="line">    ├── google.golang.org</span><br><span class="line">    ├── gopkg.in</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>GOPATH目录下一共包含了三个子目录，分别是：</p>
<ul>
<li>bin：存储所编译生成的二进制文件。</li>
<li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。</li>
<li>src：存储所有<code>.go</code>文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以<code>$GOPATH/src/github.com/foo/bar</code>的路径进行存放。</li>
</ul>
<p>因此在使用 GOPATH 模式下，我们需要将应用代码存放在固定的<code>$GOPATH/src</code>目录下，并且如果执行<code>go get</code>来拉取外部依赖会自动下载并安装到<code>$GOPATH</code>目录下。</p>
<p><strong>GOPATH模式的弊端</strong></p>
<p>在 GOPATH 的 <code>$GOPATH/src</code> 下进行 <code>.go</code> 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式拥有一些弊端.</p>
<ul>
<li><p><strong>A. 无版本控制概念.</strong> 在执行<code>go get</code>的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。</p>
</li>
<li><p><strong>B.无法同步一致第三方版本号.</strong> 在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。</p>
</li>
<li><p><strong>C.无法指定当前项目引用的第三方版本号.</strong>  你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是<code>github.com/foo/bar</code>。</p>
</li>
</ul>
<h4 id="Go-Modules模式"><a href="#Go-Modules模式" class="headerlink" title="Go Modules模式"></a>Go Modules模式</h4><p>我们接下来用Go Modules的方式创建一个项目, 建议为了与GOPATH分开,不要将项目创建在<code>GOPATH/src</code>下.</p>
<p><strong>go mod命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>go mod init</td>
<td>生成 go.mod 文件</td>
</tr>
<tr>
<td>go mod download</td>
<td>下载 go.mod 文件中指明的所有依赖</td>
</tr>
<tr>
<td>go mod tidy</td>
<td>整理现有的依赖</td>
</tr>
<tr>
<td>go mod graph</td>
<td>查看现有的依赖结构</td>
</tr>
<tr>
<td>go mod edit</td>
<td>编辑 go.mod 文件</td>
</tr>
<tr>
<td>go mod vendor</td>
<td>导出项目所有的依赖到vendor目录</td>
</tr>
<tr>
<td>go mod verify</td>
<td>校验一个模块是否被篡改过</td>
</tr>
<tr>
<td>go mod why</td>
<td>查看为什么需要依赖某模块</td>
</tr>
</tbody></table>
<p><strong>go mod环境变量</strong></p>
<p>可以通过 <code>go env</code> 命令来进行查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span></span><br><span class="line">GO111MODULE=<span class="string">&quot;auto&quot;</span></span><br><span class="line">GOPROXY=<span class="string">&quot;https://proxy.golang.org,direct&quot;</span></span><br><span class="line">GONOPROXY=<span class="string">&quot;&quot;</span></span><br><span class="line">GOSUMDB=<span class="string">&quot;sum.golang.org&quot;</span></span><br><span class="line">GONOSUMDB=<span class="string">&quot;&quot;</span></span><br><span class="line">GOPRIVATE=<span class="string">&quot;&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>GO111MODULE</strong></p>
<p>Go语言提供了 <code>GO111MODULE</code>这个环境变量来作为 Go modules 的开关，其允许设置以下参数：</p>
<ul>
<li>auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。</li>
<li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。</li>
<li>off：禁用 Go modules，不推荐设置。</li>
</ul>
<p>可以通过来设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GO111MODULE=on</span><br></pre></td></tr></table></figure>

<p><strong>GOPROXY</strong></p>
<p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy）,其作用是用于使 Go 在后续拉取模块版本时直接通过镜像站点来快速拉取。</p>
<p>GOPROXY 的默认值是：<code>https://proxy.golang.org,direct</code></p>
<p><code>proxy.golang.org</code>国内访问不了,需要设置国内的代理.</p>
<p>如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy/,direct</span><br></pre></td></tr></table></figure>

<p><strong>direct</strong></p>
<p>而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？</p>
<p>实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision…” 的错误。</p>
<p><strong>GOSUMDB</strong></p>
<p>它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。</p>
<p>GOSUMDB 的默认值为：<code>sum.golang.org</code>，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。</p>
<p>因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 <code>goproxy.cn</code> 就能支持代理 <code>sum.golang.org</code>，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。</p>
<p>另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：</p>
<ul>
<li>格式 1：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt;</code>。</li>
<li>格式 2：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt; &lt;SUMDB_URL&gt;</code>。</li>
</ul>
<p>也可以将其设置为“off”，也就是禁止 Go 在后续操作中校验模块版本。</p>
<p><strong>GONOPROXY&#x2F;GONOSUMDB&#x2F;GOPRIVATE</strong></p>
<p>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。</p>
<p>更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。</p>
<p>而一般<strong>建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE</strong>。</p>
<p>并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOPRIVATE=<span class="string">&quot;git.example.com,github.com/eddycjy/mquote&quot;</span></span><br></pre></td></tr></table></figure>

<p>设置后，前缀为 git.xxx.com 和 github.com&#x2F;eddycjy&#x2F;mquote 的模块都会被认为是私有模块。</p>
<p>如果不想每次都重新设置，我们也可以利用通配符，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOPRIVATE=<span class="string">&quot;*.example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，<strong>需要注意的是不包括 example.com 本身</strong>。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><h4 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h4><p>协程：coroutine。也叫轻量级线程。</p>
<p>与传统的系统级线程和进程相比，协程最大的优势在于“轻量级”。可以轻松创建上万个而不会导致系统资源衰竭。而线程和进程通常很难超过1万个。这也是协程别称“轻量级线程”的原因。</p>
<p>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，<strong>多个协程分享该线程分配到的计算机资源</strong>。</p>
<p>多数语言在语法层面并不直接支持协程，而是通过库的方式支持，但用库的方式支持的功能也并不完整，比如仅仅提供协程的创建、销毁与切换等能力。如果在这样的轻量级线程中调用一个同步 IO 操作，比如网络通信、本地文件读写，都会阻塞其他的并发执行轻量级线程，从而无法真正达到轻量级线程本身期望达到的目标。</p>
<p>   在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。</p>
<p>在一次并发任务中，进程、线程、协程均可以实现。从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少。</p>
<h4 id="Go并发"><a href="#Go并发" class="headerlink" title="Go并发"></a>Go并发</h4><p>Go 在语言级别支持协程，叫goroutine。Go 语言标准库提供的所有系统调用操作（包括所有同步IO操作），都会出让CPU给其他goroutine。这让轻量级线程的切换管理不依赖于系统的线程和进程，也不需要依赖于CPU的核心数量。</p>
<p>有人把Go比作21世纪的C语言。第一是因为Go语言设计简单，第二，21世纪最重要的就是并行程序设计，而Go从语言层面就支持并发。同时，并发程序的内存管理有时候是非常复杂的，而Go语言提供了自动垃圾回收机制。</p>
<p>Go语言为并发编程而内置的上层API基于顺序通信进程模型CSP(communicating sequential processes)。这就意味着显式锁都是可以避免的，因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。</p>
<p>Go语言中的并发程序主要使用两种手段来实现。goroutine和channel。</p>
<h4 id="什么是Goroutine"><a href="#什么是Goroutine" class="headerlink" title="什么是Goroutine"></a>什么是Goroutine</h4><p>goroutin是Go语言并行设计的核心，有人称之为go程。 Goroutine从量级上看很像协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p>
<p>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争。</p>
<h4 id="创建Goroutine"><a href="#创建Goroutine" class="headerlink" title="创建Goroutine"></a>创建Goroutine</h4><p>只需在函数调⽤语句前添加 <strong>go</strong> 关键字，就可创建并发执⾏单元。开发⼈员无需了解任何执⾏细节，调度器会自动将其安排到合适的系统线程上执行。</p>
<p>在并发编程中，我们通常想将一个过程切分成几块，然后让每个goroutine各自负责一块工作，当一个程序启动时，主函数在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。而go语言的并发设计，让我们很轻松就可以达成这一目的。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span>*time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个 goroutine，启动另外一个任务</span></span><br><span class="line">    <span class="keyword">go</span> newTask()</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">//main goroutine 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;main goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main goroutine: i = 1</span><br><span class="line">new goroutine: i = 1</span><br><span class="line">main goroutine: i = 2</span><br><span class="line">new goroutine: i = 2</span><br><span class="line">new goroutine: i = 3</span><br><span class="line">main goroutine: i = 3</span><br><span class="line">main goroutine: i = 4</span><br><span class="line">new goroutine: i = 4</span><br></pre></td></tr></table></figure>



<h4 id="Goroutine特性"><a href="#Goroutine特性" class="headerlink" title="Goroutine特性"></a>Goroutine特性</h4><p><strong>主goroutine退出后，其它的工作goroutine也会自动退出：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个 goroutine，启动另外一个任务</span></span><br><span class="line">    <span class="keyword">go</span> newTask()</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main goroutine <span class="built_in">exit</span></span><br><span class="line">成功: 进程退出代码 0.</span><br></pre></td></tr></table></figure>

<h4 id="Goexit函数"><a href="#Goexit函数" class="headerlink" title="Goexit函数"></a>Goexit函数</h4><p>调用 runtime.Goexit() 将立即终止当前 goroutine 执⾏，调度器确保所有已注册 defer 延迟调用被执行。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">            runtime.Goexit() <span class="comment">// 终止当前 goroutine, import &quot;runtime&quot;</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;B&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">        &#125;()</span><br><span class="line"> </span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;()       <span class="comment">//不要忘记()</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//死循环，目的不让主goroutine结束</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.defer</span><br><span class="line">A.defer</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chalice-faith.github.io/2025/10/02/Golang%E8%AF%AD%E6%B3%95%E6%96%B0%E5%A5%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/02/Golang%E8%AF%AD%E6%B3%95%E6%96%B0%E5%A5%87/" class="post-title-link" itemprop="url">Golang语法新奇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-02 20:13:15" itemprop="dateCreated datePublished" datetime="2025-10-02T20:13:15+08:00">2025-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-05 20:27:51" itemprop="dateModified" datetime="2025-10-05T20:27:51+08:00">2025-10-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="从一个main函数初见golang语法"><a href="#从一个main函数初见golang语法" class="headerlink" title="从一个main函数初见golang语法"></a>从一个main函数初见golang语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.<span class="built_in">println</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终端运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run test1_hello.go </span><br><span class="line">Hello Go</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>go run 表示 直接编译go语言并执行应用程序，一步完成你也可以先编译，然后再执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> build test1_hello.go </span><br><span class="line">$./test1_hello</span><br><span class="line">Hello Go</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行代码<strong>package main</strong>定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</p>
</li>
<li><p>下一行**import “fmt”**告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入&#x2F;输出）的函数。</p>
</li>
<li><p>下一行func main()是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</p>
</li>
<li><p><strong>注意：这里面go语言的语法，定义函数的时候，‘{’ 必须和函数名在同一行，不能另起一行。</strong></p>
<ul>
<li>下一行 &#x2F;<em>…</em>&#x2F; 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释。多行注释也叫块注释，均已以 &#x2F; <em>开头，并以</em> &#x2F; 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
<li>下一行fmt.Println(…)可以将字符串输出到控制台，并在最后自动增加换行字符 \n。 使用 fmt.Print(“hello, world\n”) 可以得到相同的结果。 Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</li>
</ul>
</li>
</ul>
<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>声明变量的一般形式是使用 var 关键字</p>
<p>第一种，指定变量类型，声明后若不赋值，使用默认值0。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name v_type</span><br><span class="line">v_name = value</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot; = %d\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> run test.go</span><br><span class="line">a = 0</span><br></pre></td></tr></table></figure>

<p>第二种，根据值自行判定变量类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name = value</span><br></pre></td></tr></table></figure>

<p>第三种，省略var, 注意 :&#x3D;左侧的变量不应该是已经声明过的，否则会导致编译错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v_name := value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">c : = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//第一种 使用默认值</span></span><br><span class="line">        <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;a = %d\n&quot;</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种</span></span><br><span class="line">        <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;b = %d\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种 省略后面的数据类型,自动匹配类型</span></span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">20</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;c = %d\n&quot;</span>, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四种 省略var关键字</span></span><br><span class="line">        d := <span class="number">3.14</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;d = %f\n&quot;</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>多变量的声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> ( <span class="comment">//这种分解的写法,一般用于声明全局变量</span></span><br><span class="line">        a <span class="type">int</span></span><br><span class="line">        b <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> e, f = <span class="number">123</span>, <span class="string">&quot;liudanbing&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这种不带声明格式的只能在函数体内声明</span></span><br><span class="line"><span class="comment">//g, h := 123, &quot;需要在func函数体内实现&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        g, h := <span class="number">123</span>, <span class="string">&quot;需要在func函数体内实现&quot;</span></span><br><span class="line">        fmt.Println(x, y, a, b, c, d, e, f, g, h)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能对g变量再次做初始化声明</span></span><br><span class="line">        <span class="comment">//g := 400</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        _, value := <span class="number">7</span>, <span class="number">5</span>  <span class="comment">//实际上7的赋值被废弃，变量 _  不具备读特性</span></span><br><span class="line">        <span class="comment">//fmt.Println(_) //_变量的是读不出来的</span></span><br><span class="line">        fmt.Println(value) <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><h4 id="优雅的常量-iota"><a href="#优雅的常量-iota" class="headerlink" title="优雅的常量 iota"></a>优雅的常量 iota</h4><p>有些概念有名字，并且有时候我们关注这些名字，甚至（特别）是在我们代码中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    CCVisa            = <span class="string">&quot;Visa&quot;</span></span><br><span class="line">    CCMasterCard      = <span class="string">&quot;MasterCard&quot;</span></span><br><span class="line">    CCAmericanExpress = <span class="string">&quot;American Express&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在其他时候，我们仅仅关注能把一个东西与其他的做区分。有些时候，有些时候一件事没有本质上的意义。比如，我们在一个数据库表中存储产品，我们可能不想以 string 存储他们的分类。我们不关注这个分类是怎样命名的，此外，该名字在市场上一直在变化。</p>
<p>我们仅仅关注它们是怎么彼此区分的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    CategoryBooks    = <span class="number">0</span></span><br><span class="line">    CategoryHealth   = <span class="number">1</span></span><br><span class="line">    CategoryClothing = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用 0, 1, 和 2 代替，我们也可以选择 17， 43， 和 61。这些值是任意的。</p>
<p>在 Go，常量有许多微妙之处。当用好了，可以使得代码非常优雅且易维护的。</p>
<h4 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h4><p>在 golang 中，一个方便的习惯就是使用iota标示符，它简化了常量用于增长数字的定义，给以上相同的值以准确的分类。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    CategoryBooks = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    CategoryHealth       <span class="comment">// 1</span></span><br><span class="line">    CategoryClothing     <span class="comment">// 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="iota和表达式"><a href="#iota和表达式" class="headerlink" title="iota和表达式"></a>iota和表达式</h4><p><code>iota</code>可以做更多事情，而不仅仅是 increment。更精确地说，<code>iota</code>总是用于 increment，但是它可以用于表达式，在常量中的存储结果值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Allergen <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    IgEggs Allergen = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>         <span class="comment">// 1 &lt;&lt; 0 which is 00000001</span></span><br><span class="line">    IgChocolate                         <span class="comment">// 1 &lt;&lt; 1 which is 00000010</span></span><br><span class="line">    IgNuts                              <span class="comment">// 1 &lt;&lt; 2 which is 00000100</span></span><br><span class="line">    IgStrawberries                      <span class="comment">// 1 &lt;&lt; 3 which is 00001000</span></span><br><span class="line">    IgShellfish                         <span class="comment">// 1 &lt;&lt; 4 which is 00010000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个工作是因为当你在一个<code>const</code>组中仅仅有一个标示符在一行的时候，它将使用增长的<code>iota</code>取得前面的表达式并且再运用它，。在 Go 语言的<a target="_blank" rel="noopener" href="https://legacy.gitbook.com/book/aceld/how-do-go/edit#">spec</a>中， 这就是所谓的隐性重复最后一个非空的表达式列表.</p>
<p>如果你对鸡蛋，巧克力和海鲜过敏，把这些 bits 翻转到 “on” 的位置（从左到右映射 bits）。然后你将得到一个 bit 值<code>00010011</code>，它对应十进制的 19。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(IgEggs | IgChocolate | IgShellfish)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 19</span></span><br><span class="line"><span class="keyword">type</span> ByteSize <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _           = <span class="literal">iota</span>                   <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)       <span class="comment">// 1 &lt;&lt; (10*1)</span></span><br><span class="line">    MB                                   <span class="comment">// 1 &lt;&lt; (10*2)</span></span><br><span class="line">    GB                                   <span class="comment">// 1 &lt;&lt; (10*3)</span></span><br><span class="line">    TB                                   <span class="comment">// 1 &lt;&lt; (10*4)</span></span><br><span class="line">    PB                                   <span class="comment">// 1 &lt;&lt; (10*5)</span></span><br><span class="line">    EB                                   <span class="comment">// 1 &lt;&lt; (10*6)</span></span><br><span class="line">    ZB                                   <span class="comment">// 1 &lt;&lt; (10*7)</span></span><br><span class="line">    YB                                   <span class="comment">// 1 &lt;&lt; (10*8)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当你在把两个常量定义在一行的时候会发生什么？</p>
<p>Banana 的值是什么？ 2 还是 3？ Durian 的值又是？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span></span><br><span class="line">    Cherimoya, Durian</span><br><span class="line">    Elderberry, Fig</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在下一行增长，而不是立即取得它的引用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apple: 1</span></span><br><span class="line"><span class="comment">// Banana: 2</span></span><br><span class="line"><span class="comment">// Cherimoya: 2</span></span><br><span class="line"><span class="comment">// Durian: 3</span></span><br><span class="line"><span class="comment">// Elderberry: 3</span></span><br><span class="line"><span class="comment">// Fig: 4</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h4><p>Go 函数可以返回多个值，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Mahesh&quot;</span>, <span class="string">&quot;Kumar&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kumar Mahesh</span><br></pre></td></tr></table></figure>

<h4 id="init函数与import"><a href="#init函数与import" class="headerlink" title="init函数与import"></a>init函数与import</h4><p>首先我们看一个例子：init函数：</p>
<p>init 函数可在package main中，可在其他package中，可在同一个package中出现多次。</p>
<p><strong>main函数</strong></p>
<p>main 函数只能在package main中</p>
<p><strong>执行顺序</strong></p>
<p>golang里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）。这两个函数在定义时不能有任何的参数和返回值。</p>
<p>虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数。</p>
<p>go程序会自动调用init()和main()，所以你不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。</p>
<p>程序的初始化和执行都起始于main包。</p>
<p>如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。</p>
<p>当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。</p>
<p>等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数如果使用参数，该变量可称为函数的形参。</p>
<p>形参就像定义在函数体内的局部变量。</p>
<p>调用函数，可以通过两种方式来传递参数：</p>
<p><strong>值传递</strong></p>
<p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<p>以下定义了 swap() 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   temp = x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">   x = y    <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，让我们使用值传递来调用 swap() 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 a 的值为 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 b 的值为 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 通过调用函数来交换值 */</span></span><br><span class="line">   swap(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   temp = x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">   x = y    <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">交换前 a 的值为 : 100</span><br><span class="line"></span><br><span class="line">交换前 b 的值为 : 200</span><br><span class="line"></span><br><span class="line">交换后 a 的值 : 100</span><br><span class="line"></span><br><span class="line">交换后 b 的值 : 200</span><br></pre></td></tr></table></figure>

<h4 id="引用传递-指针传递"><a href="#引用传递-指针传递" class="headerlink" title="引用传递(指针传递)"></a>引用传递(指针传递)</h4><p><strong>指针</strong></p>
<p>Go 语言中指针是很容易学习的，Go 语言中使用指针可以更简单的执行一些任务。</p>
<p>接下来让我们来一步步学习 Go 语言指针。</p>
<p>我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。</p>
<p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。</p>
<p>以下实例演示了变量在内存中地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span>   </span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;变量的地址: %x\n&quot;</span>, &amp;a  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量的地址: 20818a220</span><br></pre></td></tr></table></figure>

<p>现在我们已经了解了什么是内存地址和如何去访问它。接下来我们将具体介绍指针。</p>
<p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p>引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义交换值函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保持 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下我们通过使用引用传递来调用 swap() 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span>= <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 swap() 函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * &amp;a 指向 a 指针，a 变量的地址</span></span><br><span class="line"><span class="comment">   * &amp;b 指向 b 指针，b 变量的地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保存 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">交换前，a 的值 : 100</span><br><span class="line"></span><br><span class="line">交换前，b 的值 : 200</span><br><span class="line"></span><br><span class="line">交换后，a 的值 : 200</span><br><span class="line"></span><br><span class="line">交换后，b 的值 : 100</span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer语句被用于预定对一个函数的调用。可以把这类被defer语句调用的函数称为延迟函数。</p>
<p>defer作用：</p>
<ul>
<li>释放占用的资源</li>
<li>捕捉处理异常</li>
<li>输出日志</li>
</ul>
<p>结果</p>
<p>如果一个函数中有多个defer语句，它们会以LIFO（后进先出）的顺序执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Demo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="recover错误拦截"><a href="#recover错误拦截" class="headerlink" title="recover错误拦截"></a>recover错误拦截</h4><p>运行时panic异常一旦被引发就会导致程序崩溃。</p>
<p> Go语言提供了专用于“拦截”运行时panic的内建函数“recover”。它可以是当前的程序从运行时panic的状态中恢复并重新获得流程控制权。</p>
<p>**注意：**recover只有在defer调用的函数中有效.</p>
<p><strong>示例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func Demo(i int) &#123;</span><br><span class="line">	//定义10个元素的数组</span><br><span class="line">	var arr [10]int</span><br><span class="line">	//错误拦截要在产生错误前设置</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		//设置recover拦截错误信息</span><br><span class="line">		err := recover()</span><br><span class="line">		//产生panic异常  打印错误信息</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	//根据函数参数为数组元素赋值</span><br><span class="line">	//如果i的值超过数组下标 会报错误：数组下标越界</span><br><span class="line">	arr[i] = 10</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	Demo(10)</span><br><span class="line">	//产生错误后 程序继续</span><br><span class="line">	fmt.Println(&quot;程序继续执行...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runtime error: index out of range</span><br><span class="line">程序继续执行..</span><br></pre></td></tr></table></figure>

<p>如果程序没有异常，不会打印错误信息。</p>
<h2 id="slice和map"><a href="#slice和map" class="headerlink" title="slice和map"></a>slice和map</h2><p><strong>slice</strong></p>
<p>Go 语言切片是对数组的抽象。</p>
<p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片<code>(&quot;动态数组&quot;)</code>,与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p>
<h4 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h4><p>你可以声明一个未指定大小的数组来定义切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>默认切片不需要说明长度。</p>
<p>或使用make()函数来创建切片:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以简写为</span></span><br><span class="line"></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<p>也可以指定容量，其中capacity为可选参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, capacity)</span><br></pre></td></tr></table></figure>

<p>以上的len都是数组的长度也就是切片的长度</p>
<h4 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h4><p>直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap&#x3D;len&#x3D;3</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=[] <span class="type">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>初始化切片s,是数组arr的引用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:]</span><br></pre></td></tr></table></figure>

<p>将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex]</span><br></pre></td></tr></table></figure>

<p>缺省endIndex时将表示一直到arr的最后一个元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:]</span><br></pre></td></tr></table></figure>

<p>缺省startIndex时将表示从arr的第一个元素开始</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:endIndex]</span><br></pre></td></tr></table></figure>

<p>通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>

<h4 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h4><p>切片是可索引的，并且可以由 len() 方法获取长度。</p>
<p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>
<p>以下为具体实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len=3 <span class="built_in">cap</span>=5 slice=[0 0 0]</span><br></pre></td></tr></table></figure>

<h4 id="空-nil-切片"><a href="#空-nil-切片" class="headerlink" title="空(nil)切片"></a>空(nil)切片</h4><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line">切片是空的</span><br></pre></td></tr></table></figure>

<h4 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h4><p>可以通过设置下限及上限来设置截取切片*[lower-bound:upper-bound]*，实例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers ==&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">len=9 <span class="built_in">cap</span>=9 slice=[0 1 2 3 4 5 6 7 8]</span><br><span class="line">numbers == [0 1 2 3 4 5 6 7 8]</span><br><span class="line">numbers[1:4] == [1 2 3]</span><br><span class="line">numbers[:3] == [0 1 2]</span><br><span class="line">numbers[4:] == [4 5 6 7 8]</span><br><span class="line">len=0 <span class="built_in">cap</span>=5 slice=[]</span><br><span class="line">len=2 <span class="built_in">cap</span>=9 slice=[0 1]</span><br><span class="line">len=3 <span class="built_in">cap</span>=7 slice=[2 3 4]</span><br></pre></td></tr></table></figure>

<h4 id="append-和-copy-函数"><a href="#append-和-copy-函数" class="headerlink" title="append() 和 copy() 函数"></a>append() 和 copy() 函数</h4><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p>
<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len=0 <span class="built_in">cap</span>=0 slice=[]</span><br><span class="line">len=1 <span class="built_in">cap</span>=1 slice=[0]</span><br><span class="line">len=2 <span class="built_in">cap</span>=2 slice=[0 1]</span><br><span class="line">len=5 <span class="built_in">cap</span>=6 slice=[0 1 2 3 4]</span><br><span class="line">len=5 <span class="built_in">cap</span>=12 slice=[0 1 2 3 4]</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map和slice类似，只不过是数据结构不同，下面是map的一些声明方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//第一种声明</span></span><br><span class="line">    <span class="keyword">var</span> test1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    <span class="comment">//在使用map前，需要先make，make的作用就是给map分配数据空间</span></span><br><span class="line">    test1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>) </span><br><span class="line">    test1[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;php&quot;</span></span><br><span class="line">    test1[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;golang&quot;</span></span><br><span class="line">    test1[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">    fmt.Println(test1) <span class="comment">//map[two:golang three:java one:php]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种声明</span></span><br><span class="line">    test2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    test2[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;php&quot;</span></span><br><span class="line">    test2[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;golang&quot;</span></span><br><span class="line">    test2[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">    fmt.Println(test2) <span class="comment">//map[one:php two:golang three:java]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种声明</span></span><br><span class="line">    test3 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;one&quot;</span> : <span class="string">&quot;php&quot;</span>,</span><br><span class="line">        <span class="string">&quot;two&quot;</span> : <span class="string">&quot;golang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;three&quot;</span> : <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(test3) <span class="comment">//map[one:php two:golang three:java]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    language := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>][<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>][<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;php是世界上最美的语言&quot;</span></span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>][<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>][<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;golang抗并发非常good&quot;</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(language) <span class="comment">//map[php:map[id:1 desc:php是世界上最美的语言] golang:map[id:2 desc:golang抗并发非常good]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增删改查</span></span><br><span class="line">    <span class="comment">// val, key := language[&quot;php&quot;]  //查找是否有php这个子元素</span></span><br><span class="line">    <span class="comment">// if key &#123;</span></span><br><span class="line">    <span class="comment">//     fmt.Printf(&quot;%v&quot;, val)</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     fmt.Printf(&quot;no&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//language[&quot;php&quot;][&quot;id&quot;] = &quot;3&quot; //修改了php子元素的id值</span></span><br><span class="line">    <span class="comment">//language[&quot;php&quot;][&quot;nickname&quot;] = &quot;啪啪啪&quot; //增加php元素里的nickname值</span></span><br><span class="line">    <span class="comment">//delete(language, &quot;php&quot;)  //删除了php子元素</span></span><br><span class="line">    fmt.Println(language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>假设有两个方法，一个方法的接收者是指针类型，一个方法的接收者是值类型，那么：</p>
<ul>
<li>对于值类型的变量和指针类型的变量，这两个方法有什么区别？</li>
<li>如果这两个方法是为了实现一个接口，那么这两个方法都可以调用吗？</li>
<li>如果方法是嵌入到其他结构体中的，那么上面两种情况又是怎样的？</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> method1() &#123;</span><br><span class="line">    t.name = <span class="string">&quot;new name1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> method2() &#123;</span><br><span class="line">    t.name = <span class="string">&quot;new name2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    t := T&#123;<span class="string">&quot;old name&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;method1 调用前 &quot;</span>, t.name)</span><br><span class="line">    t.method1()</span><br><span class="line">    fmt.Println(<span class="string">&quot;method1 调用后 &quot;</span>, t.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;method2 调用前 &quot;</span>, t.name)</span><br><span class="line">    t.method2()</span><br><span class="line">    fmt.Println(<span class="string">&quot;method2 调用后 &quot;</span>, t.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">method1 调用前  old name</span><br><span class="line">method1 调用后  old name</span><br><span class="line">method2 调用前  old name</span><br><span class="line">method2 调用后  new name2</span><br></pre></td></tr></table></figure>

<p>当调用<code>t.method1()</code>时相当于<code>method1(t)</code>，实参和行参都是类型 T，可以接受。此时在<code>method1</code>()中的t只是参数t的值拷贝，所以<code>method1</code>()的修改影响不到main中的t变量。</p>
<p>当调用<code>t.method2()</code>&#x3D;&gt;<code>method2(t)</code>，这是将 T 类型传给了 *T 类型，go可能会取 t 的地址传进去：<code>method2(&amp;t)</code>。所以 <code>method1</code>() 的修改可以影响 t。</p>
<p>T 类型的变量这两个方法都是拥有的。</p>
<h4 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a>方法值和方法表达式</h4><p><strong>方法值</strong></p>
<p>我们经常选择一个方法，并且在同一个表达式里执行，比如常见的p.Distance()形式，实际上将其分成两步来执行也是可能的。p.Distance叫作“选择器”，选择器会返回一个方法”值”<code>一个将方法(Point.Distance)绑定到特定接收器变量的函数</code>。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器，只要传入函数的参数即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是给struct Point类型定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    distanceFormP := p.Distance   <span class="comment">// 方法值(相当于C语言的函数地址,函数指针)</span></span><br><span class="line">    fmt.Println(distanceFormP(q)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">    fmt.Println(p.Distance(q))    <span class="comment">// &quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际上distanceFormP 就绑定了 p接收器的方法Distance</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    distanceFormQ := q.Distance   <span class="comment">//</span></span><br><span class="line">    fmt.Println(distanceFormQ(p)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">    fmt.Println(q.Distance(p))    <span class="comment">// &quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际上distanceFormQ 就绑定了 q接收器的方法Distance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法”值”会非常实用.</p>
<p>举例来说，下面例子中的time.AfterFunc这个函数的功能是在指定的延迟时间之后来执行一个(译注：另外的)函数。且这个函数操作的是一个Rocket对象r</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rocket <span class="keyword">struct</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rocket)</span></span> Launch() &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">r := <span class="built_in">new</span>(Rocket)</span><br><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; r.Launch() &#125;)</span><br></pre></td></tr></table></figure>

<p>直接用方法”值”传入AfterFunc的话可以更为简短：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, r.Launch)</span><br></pre></td></tr></table></figure>

<p>省掉了上面那个例子里的匿名函数</p>
<p><strong>方法表达式</strong></p>
<p>和方法”值”相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器(p.Distance)语法来指定方法的接收器。</p>
<p>当T是一个类型时，方法表达式可能会写作<code>T.f</code>或者<code>(*T).f</code>，会返回一个函数”值”，这种函数会将其第一个参数用作接收器，所以可以用通常(译注：不写选择器)的方式来对其进行调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是给struct Point类型定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    distance1 := Point.Distance <span class="comment">//方法表达式, 是一个函数值(相当于C语言的函数指针)</span></span><br><span class="line">    fmt.Println(distance1(p, q))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, distance1) <span class="comment">//%T表示打出数据类型 ,这个必须放在Printf使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    distance2 := (*Point).Distance <span class="comment">//方法表达式,必须传递指针类型</span></span><br><span class="line">    distance2(&amp;p, q)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, distance2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">func(main.Point, main.Point) float64</span><br><span class="line">func(*main.Point, main.Point) float64</span><br><span class="line">// 这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()，</span><br><span class="line">// 但通过Point.Distance得到的函数需要比实际的Distance方法多一个参数，</span><br><span class="line">// 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数。</span><br><span class="line">// 看起来本书中函数和方法的区别是指有没有接收器，而不像其他语言那样是指有没有返回值。</span><br></pre></td></tr></table></figure>

<p>当你根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。你可以根据选择来调用接收器各不相同的方法。下面的例子，变量op代表Point类型的addition或者subtraction方法，Path.TranslateBy方法会为其Path数组中的每一个Point来调用对应的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是给struct Point类型定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Add(another Point) Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point&#123;p.X + another.X, p.Y + another.Y&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Sub(another Point) Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point&#123;p.X - another.X, p.Y - another.Y&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Print() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;&#123;%f, %f&#125;\n&quot;</span>, p.X, p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Point切片类型 Path</span></span><br><span class="line"><span class="keyword">type</span> Path []Point</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法的接收器 是Path类型数据, 方法的选择器是TranslateBy(Point, bool)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span></span> TranslateBy(another Point, add <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> op <span class="function"><span class="keyword">func</span><span class="params">(p, q Point)</span></span> Point <span class="comment">//定义一个 op变量 类型是方法表达式 能够接收Add,和 Sub方法</span></span><br><span class="line">        <span class="keyword">if</span> add == <span class="literal">true</span> &#123;</span><br><span class="line">                op = Point.Add <span class="comment">//给op变量赋值为Add方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                op = Point.Sub <span class="comment">//给op变量赋值为Sub方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> path &#123;</span><br><span class="line">                <span class="comment">//调用 path[i].Add(another) 或者 path[i].Sub(another)</span></span><br><span class="line">                path[i] = op(path[i], another)</span><br><span class="line">                path[i].Print()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        points := Path&#123;</span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">10</span>&#125;,</span><br><span class="line">                &#123;<span class="number">11</span>, <span class="number">11</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        anotherPoint := Point&#123;<span class="number">5</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        points.TranslateBy(anotherPoint, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        points.TranslateBy(anotherPoint, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;5.000000, 5.000000&#125;</span><br><span class="line">&#123;6.000000, 6.000000&#125;</span><br><span class="line">------------------</span><br><span class="line">&#123;10.000000, 10.000000&#125;</span><br><span class="line">&#123;11.000000, 11.000000&#125;</span><br></pre></td></tr></table></figure>

<h2 id="interface与类型断言"><a href="#interface与类型断言" class="headerlink" title="interface与类型断言"></a>interface与类型断言</h2><p>Golang的语言中提供了断言的功能。golang中的所有程序都实现了interface{}的接口，这意味着，所有的类型如string,int,int64甚至是自定义的struct类型都就此拥有了interface{}的接口，这种做法和java中的Object类型比较类似。那么在一个数据通过func funcName(interface{})的方式传进来的时候，也就意味着这个参数被自动的转为interface{}的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="type">string</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会返回</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert a (<span class="built_in">type</span> interface&#123;&#125;) to <span class="built_in">type</span> string: need <span class="built_in">type</span> assertion</span><br></pre></td></tr></table></figure>

<p>此时，意味着整个转化的过程需要类型断言。类型断言有以下几种形式：</p>
<h4 id="1）直接断言使用"><a href="#1）直接断言使用" class="headerlink" title="1）直接断言使用"></a>1）直接断言使用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Where are you,Jonny?&quot;</span>, a.(<span class="type">string</span>))</span><br></pre></td></tr></table></figure>

<p>但是如果断言失败一般会导致panic的发生。所以为了防止panic的发生，我们需要在断言前进行一定的判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := a.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<p>如果断言失败，那么ok的值将会是false,但是如果断言成功ok的值将会是true,同时value将会得到所期待的正确的值。示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value, ok := a.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;It&#x27;s not ok for type string&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;The value is &quot;</span>, value)</span><br></pre></td></tr></table></figure>

<p>完整例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func funcName(a interface&#123;&#125;) string &#123;</span></span><br><span class="line"><span class="comment">        return string(a)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        value, ok := a.(<span class="type">string</span>)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;It is not ok for type string&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;The value is &quot;</span>, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//      str := &quot;123&quot;</span></span><br><span class="line">        <span class="comment">//      funcName(str)</span></span><br><span class="line">        <span class="comment">//var a interface&#123;&#125;</span></span><br><span class="line">        <span class="comment">//var a string = &quot;123&quot;</span></span><br><span class="line">        <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">        funcName(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）配合switch使用"><a href="#2）配合switch使用" class="headerlink" title="2）配合switch使用"></a>2）配合switch使用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;unexpected type %T&quot;</span>, t)       <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者如下使用方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="type">uint</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> b, ok := x.(<span class="type">bool</span>); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> b &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;TRUE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FALSE&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s, ok := x.(<span class="type">string</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlQuoteString(s) <span class="comment">// (not shown)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T: %v&quot;</span>, x, x))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射reflect"><a href="#反射reflect" class="headerlink" title="反射reflect"></a>反射reflect</h2><h4 id="编程语言中反射的概念"><a href="#编程语言中反射的概念" class="headerlink" title="编程语言中反射的概念"></a>编程语言中反射的概念</h4><p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p>
<p>每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。</p>
<p>多插一句，Golang的gRPC也是通过反射实现的。</p>
<h4 id="interface-和-反射"><a href="#interface-和-反射" class="headerlink" title="interface 和 反射"></a>interface 和 反射</h4><p>在讲反射之前，先来看看Golang关于类型设计的一些原则</p>
<ul>
<li>变量包括（type, value）两部分</li>
<li>type 包括 <code>static type</code>和<code>concrete type</code>. 简单来说 <code>static type</code>是你在编码是看见的类型(如int、string)，<code>concrete type</code>是<code>runtime</code>系统看见的类型</li>
<li>类型断言能否成功，取决于变量的<code>concrete type</code>，而不是<code>static type</code>. 因此，一个 <code>reader</code>变量如果它的<code>concrete type</code>也实现了<code>write</code>方法的话，它也可以被类型断言为<code>writer</code>.</li>
</ul>
<p>接下来要讲的<code>反射</code>，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p>
<p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value, <span class="keyword">type</span>)</span><br></pre></td></tr></table></figure>

<p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。</p>
<p>例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure>

<p>接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>

<p>接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。</p>
<p>interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file error&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r io.Reader</span><br><span class="line">	r = tty</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> w io.Writer</span><br><span class="line">	w = r.(io.Writer)</span><br><span class="line">	w.Write([]<span class="type">byte</span>(<span class="string">&quot;HELLO THIS IS A TEST!!!\n&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadBook()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	WriteBook()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体类型</span></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Book)</span></span> ReadBook() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Read a book.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Book)</span></span> WriteBook() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Write a book.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := &amp;Book&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r Reader</span><br><span class="line">	r = b</span><br><span class="line"></span><br><span class="line">	r.ReadBook()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> w Writer</span><br><span class="line">	w = r.(Writer)</span><br><span class="line">	w.WriteBook()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Golang的反射reflect"><a href="#Golang的反射reflect" class="headerlink" title="Golang的反射reflect"></a>Golang的反射reflect</h4><p><strong>reflect的基本功能TypeOf和ValueOf</strong></p>
<p>既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValueOf returns a new Value initialized to the concrete value</span></span><br><span class="line"><span class="comment">// stored in the interface i.  ValueOf(nil) returns the zero </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span></span><br></pre></td></tr></table></figure>

<p>reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value，示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="type">float64</span> = <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;type: &quot;</span>, reflect.TypeOf(num))</span><br><span class="line">    fmt.Println(<span class="string">&quot;value: &quot;</span>, reflect.ValueOf(num))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line"><span class="keyword">type</span>:  <span class="type">float64</span></span><br><span class="line">value:  <span class="number">1.2345</span></span><br></pre></td></tr></table></figure>

<p>说明</p>
<ol>
<li>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</li>
<li>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</li>
<li>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</li>
</ol>
<p><strong>从relfect.Value中获取接口interface的信息</strong></p>
<p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。</p>
<p><em>已知原有类型</em>【进行“强制转换”】</p>
<p>已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realValue := value.Interface().(已知的类型)</span><br></pre></td></tr></table></figure>

<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="type">float64</span> = <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">    pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">    value := reflect.ValueOf(num)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span></span><br><span class="line">    <span class="comment">// Golang 对类型要求非常严格，类型一定要完全符合</span></span><br><span class="line">    <span class="comment">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span></span><br><span class="line">    convertPointer := pointer.Interface().(*<span class="type">float64</span>)</span><br><span class="line">    convertValue := value.Interface().(<span class="type">float64</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(convertPointer)</span><br><span class="line">    fmt.Println(convertValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">0xc42000e238</span></span><br><span class="line"><span class="number">1.2345</span></span><br></pre></td></tr></table></figure>

<p>说明</p>
<ol>
<li>转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！ </li>
<li>转换的时候，要区分是指针还是指 </li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
</ol>
<p>未知原有类型【遍历探测其Filed】</p>
<p>很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id   <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> ReflectCallFunc() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Allen.Wu ReflectCallFunc&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    user := User&#123;<span class="number">1</span>, <span class="string">&quot;Allen.Wu&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line">    DoFiledAndMethod(user)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过接口来获取任意参数，然后一一揭晓</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoFiledAndMethod</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    getType := reflect.TypeOf(input)</span><br><span class="line">    fmt.Println(<span class="string">&quot;get Type is :&quot;</span>, getType.Name())</span><br><span class="line"></span><br><span class="line">    getValue := reflect.ValueOf(input)</span><br><span class="line">    fmt.Println(<span class="string">&quot;get all Fields is:&quot;</span>, getValue)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取方法字段</span></span><br><span class="line">    <span class="comment">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span></span><br><span class="line">    <span class="comment">// 2. 再通过reflect.Type的Field获取其Field</span></span><br><span class="line">    <span class="comment">// 3. 最后通过Field的Interface()得到对应的value</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; getType.NumField(); i++ &#123;</span><br><span class="line">        field := getType.Field(i)</span><br><span class="line">        value := getValue.Field(i).Interface()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s: %v = %v\n&quot;</span>, field.Name, field.Type, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取方法</span></span><br><span class="line">    <span class="comment">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; getType.NumMethod(); i++ &#123;</span><br><span class="line">        m := getType.Method(i)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s: %v\n&quot;</span>, m.Name, m.Type)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">get Type is : User</span><br><span class="line">get all Fields is: &#123;<span class="number">1</span> Allen.Wu <span class="number">25</span>&#125;</span><br><span class="line">Id: <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">Name: <span class="type">string</span> = Allen.Wu</span><br><span class="line">Age: <span class="type">int</span> = <span class="number">25</span></span><br><span class="line">ReflectCallFunc: <span class="function"><span class="keyword">func</span><span class="params">(main.User)</span></span></span><br></pre></td></tr></table></figure>

<p>说明</p>
<p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p>
<ol>
<li>先获取interface的reflect.Type，然后通过NumField进行遍历</li>
<li>再通过reflect.Type的Field获取其Field</li>
<li>最后通过Field的Interface()得到对应的value</li>
</ol>
<p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p>
<ol>
<li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li>
<li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li>
<li>最后对结果取其Name和Type得知具体的方法名</li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<h5 id="通过reflect-Value设置实际变量的值"><a href="#通过reflect-Value设置实际变量的值" class="headerlink" title="通过reflect.Value设置实际变量的值"></a>通过reflect.Value设置实际变量的值</h5><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> num <span class="type">float64</span> = <span class="number">1.2345</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;old value of pointer:&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span></span><br><span class="line">    pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">    newValue := pointer.Elem()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, newValue.Type())</span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of pointer:&quot;</span>, newValue.CanSet())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新赋值</span></span><br><span class="line">    newValue.SetFloat(<span class="number">77</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;new value of pointer:&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////</span></span><br><span class="line">    <span class="comment">// 如果reflect.ValueOf的参数不是指针，会如何？</span></span><br><span class="line">    pointer = reflect.ValueOf(num)</span><br><span class="line">    <span class="comment">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">old value of pointer: <span class="number">1.2345</span></span><br><span class="line"><span class="keyword">type</span> of pointer: <span class="type">float64</span></span><br><span class="line">settability of pointer: <span class="literal">true</span></span><br><span class="line"><span class="built_in">new</span> value of pointer: <span class="number">77</span></span><br></pre></td></tr></table></figure>

<p>说明</p>
<p>需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</p>
<p>如果传入的参数不是指针，而是变量，那么 </p>
<ul>
<li>通过Elem获取原始值对应的对象则直接panic</li>
<li>通过CanSet方法查询是否可以设置返回false</li>
</ul>
<p>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</p>
<p>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</p>
<p>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】</p>
<p>struct 或者 struct 的嵌套都是一样的判断处理方式</p>
<h5 id="通过reflect-ValueOf来进行方法的调用"><a href="#通过reflect-ValueOf来进行方法的调用" class="headerlink" title="通过reflect.ValueOf来进行方法的调用"></a>通过reflect.ValueOf来进行方法的调用</h5><p>这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定</p>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id   <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> ReflectCallFuncHasArgs(name <span class="type">string</span>, age <span class="type">int</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ReflectCallFuncHasArgs name: &quot;</span>, name, <span class="string">&quot;, age:&quot;</span>, age, <span class="string">&quot;and origal User.Name:&quot;</span>, u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> ReflectCallFuncNoArgs() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ReflectCallFuncNoArgs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何通过反射来进行方法的调用？</span></span><br><span class="line"><span class="comment">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user := User&#123;<span class="number">1</span>, <span class="string">&quot;Allen.Wu&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span></span><br><span class="line">    getValue := reflect.ValueOf(user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一定要指定参数为正确的方法名</span></span><br><span class="line">    <span class="comment">// 2. 先看看带有参数的调用方法</span></span><br><span class="line">    methodValue := getValue.MethodByName(<span class="string">&quot;ReflectCallFuncHasArgs&quot;</span>)</span><br><span class="line">    args := []reflect.Value&#123;reflect.ValueOf(<span class="string">&quot;wudebao&quot;</span>), reflect.ValueOf(<span class="number">30</span>)&#125;</span><br><span class="line">    methodValue.Call(args)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一定要指定参数为正确的方法名</span></span><br><span class="line">    <span class="comment">// 3. 再看看无参数的调用方法</span></span><br><span class="line">    methodValue = getValue.MethodByName(<span class="string">&quot;ReflectCallFuncNoArgs&quot;</span>)</span><br><span class="line">    args = <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>)</span><br><span class="line">    methodValue.Call(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">ReflectCallFuncHasArgs name:  wudebao , age: <span class="number">30</span> and origal User.Name: Allen.Wu</span><br><span class="line">ReflectCallFuncNoArgs</span><br></pre></td></tr></table></figure>

<p>说明</p>
<ol>
<li>要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</li>
<li>reflect.Value.MethodByName这.MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。</li>
<li>[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。</li>
<li>reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value’Kind不是一个方法，那么将直接panic。</li>
<li>本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call</li>
</ol>
<h4 id="Golang的反射reflect性能"><a href="#Golang的反射reflect性能" class="headerlink" title="Golang的反射reflect性能"></a>Golang的反射reflect性能</h4><p>Golang的反射很慢，这个和它的API设计有关。在 java 里面，我们一般使用反射都是这样来弄的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = clazz.getField(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">field.get(obj1);</span><br><span class="line">field.get(obj2);</span><br></pre></td></tr></table></figure>

<p>这个取得的反射对象类型是 java.lang.reflect.Field。它是可以复用的。只要传入不同的obj，就可以取得这个obj上对应的 field。但是Golang的反射不是这样设计的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_ := reflect.TypeOf(obj)</span><br><span class="line">field, _ := type_.FieldByName(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里取出来的 field 对象是 reflect.StructField 类型，但是它没有办法用来取得对应对象上的值。如果要取值，得用另外一套对object，而不是type的反射</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_ := reflect.ValueOf(obj)</span><br><span class="line">fieldValue := type_.FieldByName(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里取出来的 fieldValue 类型是 reflect.Value，它是一个具体的值，而不是一个可复用的反射对象了，每次反射都需要malloc这个reflect.Value结构体，并且还涉及到GC。</p>
<p>Golang reflect慢主要有两个原因</p>
<ol>
<li>涉及到内存分配以及后续的GC；</li>
<li>reflect实现里面有大量的枚举，也就是for循环，比如类型之类的.</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上述详细说明了Golang的反射reflect的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：</p>
<ul>
<li><p>反射可以大大提高程序的灵活性，使得interface{}有更大的发挥余地 </p>
</li>
<li><p>反射必须结合interface才玩得转</p>
</li>
<li><p>变量的type要是concrete type的（也就是interface变量）才有反射一说</p>
</li>
<li><p>反射可以将“接口类型变量”转换为“反射类型对象” </p>
</li>
<li><p>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</p>
</li>
<li><p>反射可以将“反射类型对象”转换为“接口类型变量 </p>
</li>
<li><p>reflect.value.Interface().(已知的类型)</p>
</li>
<li><p>遍历reflect.Type的Field获取其Field</p>
</li>
<li><p>反射可以修改反射类型对象，但是其值必须是“addressable” </p>
</li>
<li><p>想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface</p>
</li>
<li><p>通过反射可以“动态”调用方法</p>
</li>
<li><p>因为Golang本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chalice-faith.github.io/2025/10/01/Docker%E5%AE%9E%E6%88%98%E6%94%BB%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/01/Docker%E5%AE%9E%E6%88%98%E6%94%BB%E7%95%A5/" class="post-title-link" itemprop="url">Docker实战攻略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-01 20:09:40" itemprop="dateCreated datePublished" datetime="2025-10-01T20:09:40+08:00">2025-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-05 21:13:43" itemprop="dateModified" datetime="2025-10-05T21:13:43+08:00">2025-10-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Docker-核心概念"><a href="#Docker-核心概念" class="headerlink" title="Docker 核心概念"></a>Docker 核心概念</h2><p><strong>Docker 容器</strong></p>
<p>Docker 简单来说就是通过容器化技术给应用程序封装一个独立的运行环境，每个运行环境就是一个容器，运行容器的计算机被称为 <strong>宿主机</strong>。</p>
<p>与虚拟机最大的区别是：<strong>Docker 容器共享同一个系统内核，而每个虚拟机都包含一个完整的系统内核。所以 Docker 容器比虚拟机更轻量，启动速度更快。</strong></p>
<p><strong>Docker 镜像</strong></p>
<p>镜像可以理解为是一个特殊的压缩包，容器就像是通过压缩包解压（创建）出来的文件，我们可以使用同一个压缩包，解压出很多份相同的文件，也可以将这个压缩包分享给他人，得到和我们一样的文件。这里所说的 “文件”，就是上面提到的容器。</p>
<p>我们也可以通过修改容器，并生成自己特定的 Docker 镜像，并将这些镜像分享给他人，其他人可以通过镜像，创建出和我们一样的容器环境。</p>
<p><strong>Docker 仓库</strong></p>
<p>Docker 仓库就是我们用来存储、分享镜像的地方。所有人都可以把自己的镜像上传到仓库里面，其他人就可以下载镜像并使用。</p>
<p>Docker 的官方仓库是 Docker Hub (<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>)</p>
<h2 id="Docker-技术原理"><a href="#Docker-技术原理" class="headerlink" title="Docker 技术原理"></a>Docker 技术原理</h2><p>Docker 利用了 Linux 的两大原生功能，实现容器化：</p>
<ul>
<li><strong>Cgroups</strong> 用来限制和隔离进程的资源使用。可以为每个容器设定 CPU、内存、网络带宽等资源的使用上限，确保容器的内存消耗不会影响到宿主机。</li>
<li><strong>Namespaces</strong> 用于隔离进程的资源视图，使得容器只能看到自己内部的进程 ID、网络资源、文件目录，看不到宿主机的。</li>
</ul>
<p>容器本质上还是一个特殊的进程，但是当我们进入容器内部时，看起来就像是一个独立的操作系统</p>
<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><p>Docker 是基于 Linux 的容器化技术，Windows 和 Mac 需要虚拟化一个 Linux 的子系统。所以 Docker 最好的使用方式是使用 Linux 系统的宿主机。</p>
<p><strong>Linux 系统</strong></p>
<p>Linux 系统可以通过包管理器安装 Docker，例如 Redhat 系可以使用 <code>yum install docker</code> 安装。</p>
<p>Alpine Linux 可以通过 <code>apk add docker</code> 安装</p>
<p><strong>Windows 安装</strong></p>
<p>打开 “Windows 功能”, 勾选上 Virtual Machine Paftform（虚拟机平台）、适用于 Linux 的 Windows 子系统，并重启电脑。</p>
<p>管理员打开命令提示符，安装 wsl2</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br><span class="line">wsl <span class="literal">--update</span> <span class="literal">--web-download</span></span><br></pre></td></tr></table></figure>

<p>去 Docker 官网 或者 <a target="_blank" rel="noopener" href="https://github.com/tech-shrimp/docker_installer/releases">https://github.com/tech-shrimp/docker_installer/releases</a> 下载符合自己系统的 Docker Desktop 安装包，并进行安装，安装成功后 可以在终端尝试一下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Administrator&gt; docker <span class="literal">--version</span></span><br><span class="line">Docker version <span class="number">28.3</span>.<span class="number">3</span>, build <span class="number">980</span>b856</span><br></pre></td></tr></table></figure>

<p>在使用的过程中 Docker Desktop 需要一直开着，否则执行命令会出现这个报错。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker ps</span><br><span class="line">error during connect: Get <span class="string">&quot;http://%2F%2F.%2Fpipe%2FdockerDesktopLinuxEngine/v1.51/containers/json&quot;</span>: open //./pipe/dockerDesktopLinuxEngine: The system cannot find the file specified.</span><br></pre></td></tr></table></figure>

<p><strong>Mac 安装</strong></p>
<p>直接在 Docker 官网下载安装包 安装就行。</p>
<h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>Docker Pull 命令用来从仓库下载镜像。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/library/nginx:latest</span><br></pre></td></tr></table></figure>

<p>一个 Docker 镜像下载地址包含 4 部分内容：</p>
<ul>
<li><strong>docker.io:</strong> registry：仓库地址 &#x2F; 注册表，如果是 Docker 官方仓库，则可以省略这个地址。</li>
<li><strong>library:</strong> 命名空间（镜像作者），为了防止不同用户上传同一个名字的镜像 发生冲突。“library” 是 docker 官方仓库的命名空间，这个空间下的所有镜像都是由 Docker 官方维护。如果是官方的命名空间 则可以省略不写</li>
<li><strong>nginx:</strong> 镜像名</li>
<li><strong>latest:</strong> 标签名、版本号。写 “latest” 或者不写 表示获取最新版本的镜像。</li>
</ul>
<p><strong>镜像库</strong></p>
<p>repository: 镜像库，存放一个镜像的不同版本，”docker.io&#x2F;library&#x2F;nginx” 就是一个镜像库。</p>
<p>简化后的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 Docker 官方仓库的官方命名空间里面下载最新的 Nginx Docker 镜像</span></span><br><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<p>其他例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 docker.n8n.io 的私有仓库下载 n8nio 上传的 n8n 镜像</span></span><br><span class="line">docker pull docker.n8n.io/n8nio/n8n</span><br></pre></td></tr></table></figure>

<p><strong>Docker Hub</strong></p>
<p>docker 官方的镜像仓库地址为 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 可以在这个上面搜索自己需要的镜像，标有 “Docker Offcial Images” 表示 Docker 官方维护的镜像。</p>
<p>如果打不开 可以通过 <a target="_blank" rel="noopener" href="https://docker.fxxk.dedyn.io/">https://docker.fxxk.dedyn.io/</a> 镜像站来搜索镜像。</p>
<p><strong>镜像源配置</strong></p>
<p>在国内的网络环境中，如果执行 <code>docker pull</code> 可能会出现 下载失败的问题，可以参考这篇文档配置镜像站解决：<a target="_blank" rel="noopener" href="https://github.com/tech-shrimp/docker_installer?tab=readme-ov-file#2-pull%E9%95%9C%E5%83%8F">docker_installer?tab&#x3D;readme-ov-file#2-pull 镜像</a></p>
<p>（我尝试了 UP 的这几个镜像 下载还是失败了，最后用这个镜像可以正常下载，有需要的各位可以试试看）</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://docker.1ms.run&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>拉取特定架构的镜像</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull --platform=xxx nginx</span><br></pre></td></tr></table></figure>

<p>默认情况下，docker 会选择当前宿主机 CPU 架构的镜像，大部分情况下我们不需要关注这个参数。</p>
<p>Mac 目前的 M 系列 CPU 都是 arm 架构的，但在运行 AMD64 架构的容器时，会自动调用 QEMU 来模拟 x86_64 指令集，从而实现兼容 AMD64 的镜像，不过可能会存在一些兼容性问题 以及额外的性能开销。</p>
<h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>使用此命令可以查看 所有 Pull 到本地的镜像。</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [镜像标识]</span><br></pre></td></tr></table></figure>

<p>使用此命令可以删除 pull 到本地的镜像，镜像标识可以选择 镜像的 ID（image id）或者镜像的名称（repository）</p>
<h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><h3 id="创建并运行容器"><a href="#创建并运行容器" class="headerlink" title="创建并运行容器"></a>创建并运行容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [镜像标识]</span><br></pre></td></tr></table></figure>

<p>使用 run 命令 可以通过 镜像创建一个容器，并启动它。镜像标识可以是 镜像 ID 或者镜像名称。</p>
<p>例如：<code>docker run nginx</code> 就是创建一个 Nginx 容器。</p>
<p>docker pull 命令可以省略，直接使用 docker run 运行，如果 docker 发现本地没有这个镜像 则会自动拉取。</p>
<p><strong>分离模式</strong></p>
<p>默认情况下 <code>docker run</code> 创建容器后会导致当前终端挂起，不能进行其他操作，可以增加 <code>-d</code> 参数 表示容器在后台运行，不阻塞当前窗口。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker run -d nginx</span><br><span class="line">c18e9f86c0c89f2d9984dbe566349542318f8e38bb86fd17579bd9f39a8c5977</span><br></pre></td></tr></table></figure>

<p><strong>自定义容器名称</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -name kz_nginx nginx</span><br></pre></td></tr></table></figure>

<p>容器的名称和 容器 ID 的效果是等价的，但是名字更方便记忆。</p>
<p><strong>端口映射</strong></p>
<p>容器的网络和宿主机的网络是隔离的，例如运行了一个 Nginx 容器，容器内的 Nginx 监听了 80 端口。这时通过宿主机的 80 端口是无法访问到 Nginx 服务的。</p>
<p>所以需要 <code>-p {宿主机端口}:{容器端口}</code> 命令进行映射，例如 <code>-p 8080:80</code> 标识将 Nginx 容器的 80 端口映射到宿主机的 8080 端口。</p>
<p><img src="/.com//docker1.webp"></p>
<p><strong>目录映射（绑定挂载）</strong></p>
<p>与端口映射类似的就是目录映射，将容器外和容器内的目录进行绑定，容器内对文件的修改会影响宿主机的文件夹，宿主机的修改也会影响容器内文件夹。这种目录也被称为 挂载卷，他的最大作用是数据的持久化。 当容器删除时，容器内的所有数据都会被删除，但通过挂载卷映射到宿主机的文件夹将得以保留。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 -v ./:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure>

<p>使用绑定挂载的时候，宿主机的文件会暂时覆盖掉容器内的目录。除了这种用法 还有一种叫 Docker 卷，可以在容器之间共享和重用。</p>
<p><strong>环境变量</strong></p>
<p>可以在命令行通过 <code>-e</code> 参数传递环境变量到容器内部，例如创建一个数据库应用，需要在 创建容器时，就指定数据库的账户、密码等信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 27017:27017 \</span><br><span class="line">-e MONGO_INITDB_ROOT_USERNAME=tech \</span><br><span class="line">-e MONGO_INITDB_ROOT_PASSWORD=dbkuaizi \</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure>

<p>如果不知道容器的环境变量有哪些，可以在 Docker Hub 上搜索一下，或者去 Github 上看一下 readme 文档，都有详细的描述。</p>
<p><strong>进入容器</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it alpine</span><br></pre></td></tr></table></figure>

<p>通过 <code>-it</code> 参数可以在创建一共容器时，同时进入容器内部的终端。</p>
<p><strong>退出删除</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> alpine</span><br></pre></td></tr></table></figure>

<p><code>--rm</code> 表示当退出容器时，自动删除这个容器。一般和 <code>-it</code> 命令配合使用</p>
<p><strong>容器重启策略</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart always nginx</span><br></pre></td></tr></table></figure>

<p><code>--restart</code> 参数用来表示 容器在停止时的重启策略，它有两个选项：</p>
<ul>
<li><code>always</code> 只要容器停止了，就会立即重启。包含容器因为内部错误崩溃，或者宿主机断电等场景</li>
<li><code>unless-stopped</code> ，与 <code>always</code> 类似，唯一区别是：手动停止的容器不会尝试重启了</li>
</ul>
<h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create nginx</span><br></pre></td></tr></table></figure>

<p>与 run 命令功能类似，区别在于只创建容器，不自动启动。</p>
<h3 id="容器列表"><a href="#容器列表" class="headerlink" title="容器列表"></a>容器列表</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS     NAMES</span><br><span class="line">48fe482ecff2   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   About a minute ago   Up About a minute   80/tcp    cool_hodgkin</span><br></pre></td></tr></table></figure>

<p>ps 是 Process Status (进程状态) 的缩写，也是 Linux 上的一个经典命令，用于查看进程的状态信息。这一命令也被继承到 Docker 里面了</p>
<p>这些列含义如下：</p>
<ul>
<li><code>CONTAINER ID</code> 容器 ID，每个容器在创建时会生成一个唯一的 ID</li>
<li><code>IMAGE</code> 基于那个镜像创建出来的</li>
<li><code>CREATED</code> 镜像创建时间</li>
<li><code>STATUS</code> 镜像当前状态</li>
<li><code>PORTS</code> 镜像使用端口</li>
<li><code>NAMES</code> 容器的名字，如果创建容器时没有指定名字，系统就会随机分配一个。</li>
</ul>
<p>增加 <code>-a</code> 参数可以看到所有的容器，包括正在运行的和已经停止的。</p>
<h3 id="启停容器"><a href="#启停容器" class="headerlink" title="启停容器"></a>启停容器</h3><p>每次使用 <code>docker run</code> 运行都会创建一个新的容器，如果我们需要对同一个容器进行持续的操作，可以通过 容器的启停命令来控制。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start &#123;容器标识&#125;</span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>start</code> 启停容器的时候，不需要再传递创建容器时的 端口映射、挂载卷、环境变量等参数都不需要重新写了，docker 已经自动保存了，重新启动可以按照原因运行。</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>使用 rm 命令可以删除容器，如果要删除运行中的容器 需要加 <code>-f</code> 参数强制删除。</p>
<h3 id="容器内部"><a href="#容器内部" class="headerlink" title="容器内部"></a>容器内部</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &#123;容器标识&#125; bash</span><br></pre></td></tr></table></figure>

<p>使用 <code>exec -it</code> 命令 可以进入容器，在容器内部执行 shell 命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> &#123;容器标识&#125; &#123;shell 命令&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过这种方式 在容器外部执行容器内部的命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器 alpine 中的进程信息</span></span><br><span class="line">docker <span class="built_in">exec</span> alpine ps -ef</span><br></pre></td></tr></table></figure>

<p>注意 docker 镜像为了尽可能缩小镜像体积，内部一般是一个极简的操作系统，很多系统工具、基础命令都是缺失的</p>
<h3 id="查看创建信息"><a href="#查看创建信息" class="headerlink" title="查看创建信息"></a>查看创建信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>使用这个命令可以看到容器的所有信息，输出的是一个 JSON 格式，可以直接丢给 ai 帮忙解析</p>
<h3 id="容器日志"><a href="#容器日志" class="headerlink" title="容器日志"></a>容器日志</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>这个命令可以看容器的日志，加上 <code>-f</code> 命令，可以持续输出，滚动查看。</p>
<h2 id="Docker-卷"><a href="#Docker-卷" class="headerlink" title="Docker 卷"></a>Docker 卷</h2><p>docker volume 命令用于管理 Docker 卷（volume）。卷是用于持久化数据的文件系统，可以将数据和应用程序分离，便于管理，可以在容器之间共享和重用。同时卷可以用于数据的备份和恢复。</p>
<h3 id="创建卷"><a href="#创建卷" class="headerlink" title="创建卷"></a>创建卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create &#123;卷名称&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查看卷信息"><a href="#查看卷信息" class="headerlink" title="查看卷信息"></a>查看卷信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect nginx_html</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2025-09-07T14:58:39Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/nginx_html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;nginx_html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="查看所有卷"><a href="#查看所有卷" class="headerlink" title="查看所有卷"></a>查看所有卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume list</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     nginx_html</span><br></pre></td></tr></table></figure>



<h3 id="删除卷"><a href="#删除卷" class="headerlink" title="删除卷"></a>删除卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">rm</span> nginx_html</span><br></pre></td></tr></table></figure>



<h3 id="删除未使用的卷"><a href="#删除未使用的卷" class="headerlink" title="删除未使用的卷"></a>删除未使用的卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure>



<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是一个用来 构建镜像文件的文本文件，Dockerfile 文件内包含了构建镜像所需的各种信息。</p>
<p>在项目目录下创建一个名为 <code>Dockerfile</code> 的文件，并在文件中编写镜像构成的信息。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择一个基础镜像作为运行环境</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.13</span>-slim</span><br><span class="line"><span class="comment"># 在镜像内切换一个工作目录，后续所有的操作都是基于这个目录来的</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 将项目文件拷贝到镜像的工作目录</span></span><br><span class="line"><span class="comment"># 第一个 “.” 代表当前目录，第二个 “.” 代表镜像的工作目录 </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装容器内环境需要的依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明对外提供服务的端口是哪个</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器内服务启动命令，每次启动时容器内会自动执行这个命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>,<span class="string">&quot;main.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>项目内容</strong><br>main.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;hello&quot;</span>:<span class="string">&quot;dbkuaizi&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    uvicorn.run(app,host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<p>requirements.txt</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastapi</span><br><span class="line">uvicorn</span><br></pre></td></tr></table></figure>

<p><strong>构建镜像</strong></p>
<p>Dockerfile 文件写好了，可以使用 <code>docker build</code> 构建镜像。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\demo&gt; docker build -t docker_test .</span><br><span class="line">[+] Building 65.7s (9/9) FINISHED                                                                                                                                                                                                                                  docker:desktop-linux</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                                                                                                                                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 616B                                                                                                                                                                                                                                               0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/python:3.13-slim                                                                                                                                                                                                                0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                                                                                                                                                                                                    0.0s</span><br><span class="line"> =&gt; [1/4] FROM docker.io/library/python:3.13-slim@sha256:1bca0202e953784ac2a1daf36ebbc9cbebed48afcfba12d1225aaab3793eca33                                                                                                                                                          0.0s</span><br><span class="line"> =&gt; =&gt; resolve docker.io/library/python:3.13-slim@sha256:1bca0202e953784ac2a1daf36ebbc9cbebed48afcfba12d1225aaab3793eca33                                                                                                                                                          0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                                                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 310B                                                                                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; CACHED [2/4] WORKDIR /app                                                                                                                                                                                                                                                      0.0s</span><br><span class="line"> =&gt; [3/4] COPY . .                                                                                                                                                                                                                                                                 0.1s</span><br><span class="line"> =&gt; [4/4] RUN pip install -r requirements.txt                                                                                                                                                                                                                                     63.6s</span><br><span class="line"> =&gt; exporting to image                                                                                                                                                                                                                                                             1.6s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                                                                                                                                                                                            0.9s</span><br><span class="line"> =&gt; =&gt; exporting manifest sha256:fb2f23e7feeb23365ee8cc3cd9a5a8c5d497c73538c16463e23195a6b873d7bf                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting config sha256:41ffab42f6b9d9c336023838318f252e00e15a9d5a73cc17a765dae05fdc5435                                                                                                                                                                                    0.0s</span><br><span class="line"> =&gt; =&gt; exporting attestation manifest sha256:83d850f342fee281553b7b387484f4790d4553015fb12d4cec7ac00462229a25                                                                                                                                                                      0.0s</span><br><span class="line"> =&gt; =&gt; exporting manifest list sha256:1bfb1d56ae1e7a710f2f6277d9c2a6b2b746e6710a83b1792bea01ef7bbec520                                                                                                                                                                             0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/docker_test:latest                                                                                                                                                                                                                              0.0s</span><br><span class="line"> =&gt; =&gt; unpacking to docker.io/library/docker_test:latest    </span><br></pre></td></tr></table></figure>

<p><strong>创建容器并运行</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\demo&gt; docker run -d -p 8000:8000 docker_test</span><br><span class="line">22fd617066ad0f95b1a664257f4c00a6dc1b60d9de7c894f8940f24b34859629</span><br><span class="line">PS E:\docker\demo&gt; docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED         STATUS                     PORTS                                         NAMES</span><br><span class="line">22fd617066ad   docker_test   <span class="string">&quot;python3 main.py&quot;</span>        4 seconds ago   Up 4 seconds               0.0.0.0:8000-&gt;8000/tcp, [::]:8000-&gt;8000/tcp   sharp_banach</span><br><span class="line">PS E:\docker\demo&gt; curl http://127.0.0.1:8000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StatusCode        : 200</span><br><span class="line">StatusDescription : OK</span><br><span class="line">Content           : &#123;<span class="string">&quot;hello&quot;</span>:<span class="string">&quot;dbkuaizi&quot;</span>&#125;</span><br><span class="line">RawContent        : HTTP/1.1 200 OK</span><br><span class="line">                    Content-Length: 20</span><br><span class="line">                    Content-Type: application/json</span><br><span class="line">                    Date: Tue, 09 Sep 2025 14:31:30 GMT</span><br><span class="line">                    Server: uvicorn</span><br><span class="line"></span><br><span class="line">                    &#123;<span class="string">&quot;hello&quot;</span>:<span class="string">&quot;dbkuaizi&quot;</span>&#125;</span><br><span class="line">Forms             : &#123;&#125;</span><br><span class="line">Headers           : &#123;[Content-Length, 20], [Content-Type, application/json], [Date, Tue, 09 Sep 2025 14:31:30 GMT], [Server, uvicorn]&#125;</span><br><span class="line">Images            : &#123;&#125;</span><br><span class="line">InputFields       : &#123;&#125;</span><br><span class="line">Links             : &#123;&#125;</span><br><span class="line">ParsedHtml        : System.__ComObject</span><br><span class="line">RawContentLength  : 20</span><br></pre></td></tr></table></figure>



<h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>Docker 网络 默认 Bridge（桥接模式），所有的容器都连接到这个网络中，每一个容器都分配了一个内部的 IP 地址，一般都是 172.17 开头。在这个内部子网里面，容器可以通过内部 IP 地址互相访问。</p>
<p>但<strong>容器网络和宿主机的网络是隔离的</strong>，可以使用 <code>docker network create</code> 命令创建子网，默认情况下，子网也是桥接模式的一种，然后可以指定容器加入不同的子网，同一个子网内的容器可以互相通信，而跨子网则不可以通信。</p>
<p>使用子网还有一个好处，同一个子网内的容器，可以直接使用容器名称互相访问，而不必使用内部的 IP 地址。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 名叫 network1 的子网</span></span><br><span class="line">docker network create network1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 nginx 容器 使用 network1 的子网</span></span><br><span class="line">docker run -d --network network1 nginx</span><br></pre></td></tr></table></figure>

<p><img src="/.com//docker2.webp"></p>
<h3 id="HOST-模式"><a href="#HOST-模式" class="headerlink" title="HOST 模式"></a>HOST 模式</h3><p>host 模式下，docker 容器直接共享宿主机的网络，容器直接使用宿主机的 IP 地址，无需 <code>-p</code> 参数进行端口映射，容器内的服务直接运行在宿主机的端口上，通过宿主机的 IP 和端口就能访问到容器中服务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network host nginx</span><br></pre></td></tr></table></figure>



<h3 id="NONE-模式"><a href="#NONE-模式" class="headerlink" title="NONE 模式"></a>NONE 模式</h3><p>这个模式表示不联网</p>
<h3 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h3><p><strong>创建网络</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create network1</span><br></pre></td></tr></table></figure>

<p><strong>查看网络</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker network list</span><br><span class="line">NETWORK ID     NAME       DRIVER    SCOPE</span><br><span class="line">d30095b3bc13   bridge     bridge    <span class="built_in">local</span></span><br><span class="line">24b646446630   host       host      <span class="built_in">local</span></span><br><span class="line">a26161c3eff2   network1   bridge    <span class="built_in">local</span></span><br><span class="line">7800c9b21eb6   none       null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>除了我们创建的模式以外，还有 Docker 自带的三种模式，需要注意的是 这三个自带的网络模式是不可删除的</p>
<p><strong>删除网络</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">rm</span> network1</span><br></pre></td></tr></table></figure>



<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>有的时候 一个完整的应用可能会是很多部分组成的，例如前端、后端、数据库 以及各种附加的技术栈，这些东西应该如何容器化呢？</p>
<p>我们可以自然的想到，将这些模块都打包在一起，做成一个巨大的容器。但这样做有一个弊端，只要其中一个模块发生故障，例如 服务端内存泄露，可能会导致整个容器都崩溃挂掉。</p>
<p>并且这样做的可伸缩性差，如果想给系统做扩容，只能把整个大容器在复制一份，做不到对某个模块的精确扩容。</p>
<p>多应用的最佳实践，是把每一个模块都打包成一个独立的容器。但这样多容器 增加了很多使用成本，因为想创建多个 容器 就要多次使用 docker run ，还需要配置容器之间的网络环境，尝试管理这些容器时，一个遗漏就会导致很多问题，并且若让其他人部署项目，如果操作者对部署流程不熟悉 也会导致各种问题的发生。</p>
<p>这个时候，容器编排技术就很有用了，也就是 <strong>Docker Compose</strong>，它使用 yml 文件 管理多个容器，在这个文件中记录了容器之间时如何创建以及如何协同工作的，我们可以简单的把 Docker Compose 文件理解成一个或多个 Docker run 命令，按照特定的格式书写到一个文件中，</p>
<p>Docker Compose 格式如下：</p>
<p><img src="/.com//docker3.webp"></p>
<ul>
<li>右侧最顶级的就是 Services 元素，每个元素就对应一个 Services</li>
<li>左侧的 <code>--name</code> 在右侧就变成了 services 名</li>
<li>左侧的镜像名，在右侧写在了 <code>image:</code> 属性后面</li>
<li>左侧的 <code>-e</code> 参数，对应右边的 <code>environments</code></li>
<li>左侧的 <code>-v</code> 对应右侧的 <code>volume</code> 也就是挂载卷。</li>
<li>左侧的 <code>-p</code> 对应右边的 <code>ports</code></li>
<li>右侧的 <code>depends_on</code> 用来表示启动顺序关系，这里表示 <code>my_mongodb_express</code> 容器，依赖 <code>my_mongodb</code> 。这时 程序会先启动 mongodb 再启动荣亲</li>
</ul>
<p>左右两边唯一的区别是：左边自定义了一个子网 <code>network1</code> ，而右边没有。同一个 <code>compose</code> 文件中，定义的所有容器都会自动加入同一个子网，不用我们额外维护。</p>
<p>我们可以借助 AI 来生成 需要的 Compose 文件，而无需手动编写。</p>
<p><strong>使用 Compose</strong></p>
<p>在启动目录下创建 <code>docker-compose.yaml</code> 文件，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_mongodb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_ROOT_USERNAME:</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_ROOT_PASSWORD:</span> <span class="string">pass</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/my/datadir:/data/db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">my_mongodb_express:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo-express</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8081</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ME_CONFIG_MONGODB_SERVER:</span> <span class="string">my_mongodb</span></span><br><span class="line">      <span class="attr">ME_CONFIG_MONGODB_ADMINUSERNAME:</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">ME_CONFIG_MONGODB_ADMINPASSWORD:</span> <span class="string">pass</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_mongodb</span></span><br></pre></td></tr></table></figure>

<p><strong>创建并运行启动</strong></p>
<p>然后执行 <code>docker compose up -d</code> 运行，如果容器已经在运行了 重复执行这个命令不会有任何效果。</p>
<p>执行该命令时，会检测当前目录下 名为 <code>docker-compose.yaml</code> 或 <code>compose.yaml</code> 文件。可以通过 <code>docker compose -f tesst.yaml up -d</code> 指定 compose 文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS E:\dbkuaizi\mongodb&gt; docker compose up -d</span><br><span class="line">[+] Running 3/3</span><br><span class="line"> ✔ Network mongodb_default                 Created                                                                 0.0s</span><br><span class="line"> ✔ Container mongodb-my_mongodb-1          Started                                                                 0.6s</span><br><span class="line"> ✔ Container mongodb-my_mongodb_express-1  Started                                                                 0.7s</span><br><span class="line">PS E:\dbkuaizi\mongodb&gt;</span><br></pre></td></tr></table></figure>

<p><strong>停止并删除</strong></p>
<p><code>docker compose down</code> 命令会停止并删除容器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\mongodb&gt; docker compose down</span><br><span class="line"><span class="keyword">time</span>=<span class="string">&quot;2025-09-18T21:47:55+08:00&quot;</span> level=warning msg=<span class="string">&quot;E:\\docker\\mongodb\\docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion&quot;</span></span><br><span class="line">[+] Running 3/3</span><br><span class="line"> ✔ Container mongodb-my_mongodb_express-1  Removed                                                                 0.3s</span><br><span class="line"> ✔ Container mongodb-my_mongodb-1          Removed                                                                 0.3s</span><br><span class="line"> ✔ Network mongodb_default                 Removed                                                                 0.4s</span><br></pre></td></tr></table></figure>

<p><strong>停止不删除</strong></p>
<p><code>docker compose stop</code> 命令会停止并且不会删除容器</p>
<p><strong>启动</strong></p>
<p><code>docker compose start</code> 命令会启动停止的容器</p>
<h2 id="Docker练习地址"><a href="#Docker练习地址" class="headerlink" title="Docker练习地址"></a>Docker练习地址</h2><p><a target="_blank" rel="noopener" href="https://labs.play-with-docker.com/">labs.play-with-docker.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chalice-faith.github.io/2025/10/01/Golang%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/01/Golang%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Golang环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-01 09:07:54 / 修改时间：12:42:42" itemprop="dateCreated datePublished" datetime="2025-10-01T09:07:54+08:00">2025-10-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Golang开发环境"><a href="#Golang开发环境" class="headerlink" title="Golang开发环境"></a>Golang开发环境</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>Go官网下载地址：<a target="_blank" rel="noopener" href="https://golang.org/dl/">https://golang.org/dl/</a></p>
<p>Go官方镜像站（推荐）：<a target="_blank" rel="noopener" href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p>
<p>根据自己系统，自行选择安装。如果是window系统 推荐下载可执行文件版,一路 Next。</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>GOROOT是安装包bin\go.exe所在的路径，GOPATH是Go工具包所在的路径。新增以下用户变量</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GOROOT = E:\Github\Go;//Go安装位置</span><br><span class="line">GOPATH = E:\GoProject;//Go项目文件位置</span><br></pre></td></tr></table></figure>

<p>右击桌面左下角【开始】–》设置 –》输入”环境”关键字，选择”编辑系统环境变量” –》环境变量 –》用户变量 –》Path –》编辑 ，新增以下内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path = %GOROOT%\bin;%GOPATH%\bin;</span><br></pre></td></tr></table></figure>

<h3 id="配置Go代理和Go包校验方式"><a href="#配置Go代理和Go包校验方式" class="headerlink" title="配置Go代理和Go包校验方式"></a>配置Go代理和Go包校验方式</h3><p>win+r打开cmd，在命令行输入以下命令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go env -w GOSUMDB=sum.golang.google.cn</span><br></pre></td></tr></table></figure>

<h3 id="验证Go环境"><a href="#验证Go环境" class="headerlink" title="验证Go环境"></a>验证Go环境</h3><p>在cmd中输入</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure>

<p>查看GOPROXY和GOSUMDB是否修改成功，成功则在windows环境下配置完成。</p>
<h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>环境配置完成，编写以下代码并运行以测试环境是否能正常使用。</p>
<p>在Go项目项目文件创建一个test文件夹，进入文件夹创建一个名为test.go的文件，并输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> fmt</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Golang!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后运行成功，可以开始编写你的Golang代码了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chalice-faith.github.io/2025/09/25/C++%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/25/C++%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/" class="post-title-link" itemprop="url">C++的移动语义和完美转发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-25 22:36:17 / 修改时间：22:43:08" itemprop="dateCreated datePublished" datetime="2025-09-25T22:36:17+08:00">2025-09-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>C++11 引入了<strong>移动语义</strong>，利用<strong>右值引用</strong>接收临时对象或将亡值，将其内部资源（如堆内存、文件句柄等）直接搬移到新对象，而不是分配新内存并复制内容，从而极大地提升效率。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a><strong>右值引用</strong></h3><p> 右值引用的语法为T&amp;&amp;，能够绑定到纯右值或将亡值。例如： 	</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string s2 = std::<span class="built_in">move</span>(str); <span class="comment">// s2 从 str 搬移资源后，str 变为空</span></span><br></pre></td></tr></table></figure>

<p>此处，std::move(str)会将str强制转换为右值，使得s2调用<strong>移动构造函数</strong>，而非深拷贝。这时str内部的缓冲区指针直接转移给了s2，str本身被置为空状态。 	</p>
<h3 id="移动构造函数与移动赋值运算符"><a href="#移动构造函数与移动赋值运算符" class="headerlink" title="移动构造函数与移动赋值运算符"></a><strong>移动构造函数与移动赋值运算符</strong></h3><p> 如果希望自定义类型支持移动语义，需要为其提供<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Buffer</span>(<span class="type">size_t</span> n) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[n]), <span class="built_in">size</span>(n) &#123;&#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Buffer</span>(Buffer&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">data</span>(other.data), <span class="built_in">size</span>(other.size) </span><br><span class="line">    &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    Buffer&amp; <span class="keyword">operator</span>=(Buffer&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">            data = other.data;</span><br><span class="line">            size = other.size;</span><br><span class="line">            other.data = <span class="literal">nullptr</span>;</span><br><span class="line">            other.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Buffer</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当使用<strong>右值</strong>或<strong>将亡值</strong>初始化或赋值时，将直接搬移指针和大小信息，而不是重新分配内存并复制元素。 		</p>
<p>搬移完成后，原对象other会被置为空（data &#x3D; nullptr、size &#x3D; 0），保证析构时不会重复释放资源。</p>
<h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a><strong>完美转发</strong></h2><p> 在模板函数中，如果将参数直接传给另一个重载函数或工厂函数，往往会丢失原有的<strong>左值&#x2F;右值</strong>属性。例如： 	</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(param); <span class="comment">// 不能区分 param 本身是左值还是右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若param本身绑定了<strong>右值</strong>，但直接调用func(param)时会被视为<strong>左值</strong>，无法调用接受右值的重载。为了解决这一问题，需要使用<strong>完美转发</strong>，借助std::forward保留原始值类别。 	</p>
<h3 id="模板参数折叠规则与std-forward"><a href="#模板参数折叠规则与std-forward" class="headerlink" title="模板参数折叠规则与std::forward"></a><strong>模板参数折叠规则与std::forward</strong></h3><p> C++11 引入了<strong>引用折叠</strong>规则： 	</p>
<p>当模板参数T被推导为一个左值引用类型（如T&amp;）时，T&amp;&amp;会折叠为T&amp;（普通左值引用）。 		</p>
<p>当T被推导为一个非引用类型时，T&amp;&amp;为真正的右值引用。<br> 基于此，std::forward<T>(param)根据T的实际类型，返回相应的左值或右值。示例： 		</T></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(param)); <span class="comment">// 保留 param 的值类别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实参是左值，T推导为T&amp;，此时std::forward<T>(param)会将param当作左值传递。 		</T></p>
<p>如果实参是右值，T推导为普通类型T，此时std::forward<T>(param)会将param当作右值传递。</T></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// std::forward, std::move</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理左值引用: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::string&amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理右值引用: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完美转发，将 param 原封不动地传给 process</span></span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;示例&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动语义示例</span></span><br><span class="line">    std::string a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string b = std::<span class="built_in">move</span>(a);  <span class="comment">// b 从 a 搬移资源后，a 变为空</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完美转发示例</span></span><br><span class="line">    <span class="built_in">wrapper</span>(str);                   <span class="comment">// 调用左值版本</span></span><br><span class="line">    <span class="built_in">wrapper</span>(std::<span class="built_in">move</span>(str));        <span class="comment">// 调用右值版本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">a = , b = Hello</span></span><br><span class="line"><span class="comment">处理左值引用: 示例</span></span><br><span class="line"><span class="comment">处理右值引用: 示例</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 <strong>移动语义</strong> 部分，std::move(a)将a转为右值，使得b调用 <strong>移动构造函数</strong>，从a搬移内部资源；搬移后a变为空字符串。</p>
<p>在 <strong>完美转发</strong> 部分，模板wrapper使用T&amp;&amp;接收任意值类别的实参，再通过std::forward<T>(param)完美转发给重载的process函数，保留了左值或右值属性，分别调用对应的重载版本。</T></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>移动语义</strong>：通过<strong>右值引用</strong>将资源从临时对象或将亡值搬移到新对象，避免不必要的拷贝开销。</li>
<li><strong>完美转发</strong>：在模板函数中使用std::forward将参数原封不动地转发给另一个函数，保留左值或右值属性。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chalice-faith.github.io/2025/09/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FII/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FII/" class="post-title-link" itemprop="url">单例模式II</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-24 21:48:09 / 修改时间：22:14:26" itemprop="dateCreated datePublished" datetime="2025-09-24T21:48:09+08:00">2025-09-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="智能指针单例实现方式"><a href="#智能指针单例实现方式" class="headerlink" title="智能指针单例实现方式"></a>智能指针单例实现方式</h2><p>我们能想到一个自动初始化资源并且自动释放的方式就是智能指针。利用智能指针自动回收资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAuto</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAuto</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">SingleAuto</span>(<span class="type">const</span> SingleAuto&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    SingleAuto&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAuto&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; <span class="title">GetInst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        single=std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">        s_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mtx; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试用代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;SingleAuto&gt; SingleAuto::single=<span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleAuto::s_mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_singleauto</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> sp1=SingleAuto::<span class="built_in">GetInst</span>();</span><br><span class="line">	<span class="keyword">auto</span> sp2=SingleAuto::<span class="built_in">GetInst</span>();</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;sp1 is:&quot;</span>&lt;&lt;sp1&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;sp2 is:&quot;</span>&lt;&lt;sp2&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板单例类实现"><a href="#模板单例类实现" class="headerlink" title="模板单例类实现"></a>模板单例类实现</h2><p>为了使用单例类更通用，比如项目中使用多个单例类，可以通过继承实现多个单例类。</p>
<p>C++11 提出了<code>call_once</code>函数，我们可以配合一个局部的静态变量<code>once_flag</code>实现线程安全的初始化。<br>多线程调用<code>call_once</code>函数时，会判断<code>once_flag</code>是否被初始化，如没被初始化则进入初始化流程，调用我们提供的初始化函数。<br>但是同一时刻只有一个线程能进入这个初始化函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&lt;T&gt;&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt;&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;T&gt; _instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">GetInst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag s_flags;</span><br><span class="line">        std::<span class="built_in">call_once</span>(s_flags,[&amp;]()&#123;</span><br><span class="line">            _instance=std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">   	~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;The Singleton is delete!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chalice-faith.github.io/2025/09/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-23 21:36:48 / 修改时间：22:21:39" itemprop="dateCreated datePublished" datetime="2025-09-23T21:36:48+08:00">2025-09-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍线程安全C++单例模式的实现</p>
<h2 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h2><p>如果一个函数中定义一个局部静态变量，那么这个静态变量只会初始化一次，就是在这个函数第一次调用的时候，以后无论调用几次这个函数，函数内的静态变量不在初始化。在C++11后局部静态变量不会出现在多线程情况下初始化多个静态变量。所以我们可以利用局部静态变量这一特点实现单例模式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="type">static</span> &amp;Singleton <span class="title">GetInst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="type">static</span> Singleton single;</span><br><span class="line">    	<span class="keyword">return</span> single;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="饿汉式初始化"><a href="#饿汉式初始化" class="headerlink" title="饿汉式初始化"></a>饿汉式初始化</h2><p>在C++11之前，局部静态变量会出现线程安全问题，所以部分人推出了一种方案，就是在主线程启动后，在其他线程还没有启动前，由主线程初始化单例资源，这样其他线程获取的单例线程就不会涉及重复初始化的情况了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonHungry</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">SingletonHungry</span>()&#123;&#125;    </span><br><span class="line">    <span class="built_in">SingletonHungry</span>(<span class="type">const</span> SingletonHungry&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    SingletonHungry&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingletonHungry&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingletonHungry* <span class="title">GetInst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            single = <span class="keyword">new</span> SingletonHungry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SingletonHungry* single; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式初始化</span></span><br><span class="line">Single2Hungry* Single2Hungry::single = Single2Hungry::<span class="built_in">GetInst</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_s2</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is thread &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;inst is &quot;</span> &lt;&lt; Single2Hungry::<span class="built_in">GetInst</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_single2hungry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 addr is &quot;</span> &lt;&lt; Single2Hungry::<span class="built_in">GetInst</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2 addr is &quot;</span> &lt;&lt; Single2Hungry::<span class="built_in">GetInst</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">tid</span><span class="params">(thread_func_s2, i)</span></span>;</span><br><span class="line">        tid.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式是从使用角度规避多线程的安全问题，很多情况下我们很难从规则角度限制开发人员，所以这种方式不是很推荐。</p>
<h2 id="懒汉式初始化"><a href="#懒汉式初始化" class="headerlink" title="懒汉式初始化"></a>懒汉式初始化</h2><p>很多人觉得什么时候调用初始化是用户的权利，不应该加以限制，所以就有了懒汉式方式初始化资源，在用到时如果没有初始化单例则初始化，如果初始化了则直接使用，所以这种方式我们要加锁，防止资源被重复初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SinglePointer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">SinglePointer</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">SinglePointer</span>(<span class="type">const</span> SinglePointer&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    SinglePointer <span class="keyword">operator</span>=(<span class="type">const</span> SinglePointer&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SinglePointer* <span class="title">GetInst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        single=<span class="keyword">new</span> <span class="built_in">SinglePointer</span>();</span><br><span class="line">        s_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SinglePointer* single;</span><br><span class="line">    std::mutex s_mtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SinglePointer* SinglePointer::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SinglePointer::s_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_lazy</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is lazy thread &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;inst is &quot;</span> &lt;&lt; SinglePointer::<span class="built_in">GetInst</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_singlelazy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">tid</span><span class="params">(thread_func_lazy, i)</span></span>;</span><br><span class="line">        tid.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//何时释放new的对象？造成内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式存在一个很严重的问题，就是当多个线程都调用单例函数时，我们不确定资源是被哪个线程初始化的。<br>回收指针存在问题，存在多重释放或者不知道哪个指针释放的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chalice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chalice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
