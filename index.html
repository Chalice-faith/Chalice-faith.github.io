<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Chalice 的技术博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Chalice 的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chalice">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chalice 的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chalice 的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/Linux%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9CIO%E5%A4%8D%E7%94%A8%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/05/Linux%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9CIO%E5%A4%8D%E7%94%A8%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Linux中的网络IO复用并发模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-05 16:32:30" itemprop="dateCreated datePublished" datetime="2025-10-05T16:32:30+08:00">2025-10-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/04/Golang%E5%AE%9E%E6%88%98-IMSystem1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/04/Golang%E5%AE%9E%E6%88%98-IMSystem1/" class="post-title-link" itemprop="url">Golang实战-IMSystem1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-04 22:27:40" itemprop="dateCreated datePublished" datetime="2025-10-04T22:27:40+08:00">2025-10-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/04/Golang%E9%AB%98%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/04/Golang%E9%AB%98%E9%98%B6/" class="post-title-link" itemprop="url">Golang高阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-04 22:26:59" itemprop="dateCreated datePublished" datetime="2025-10-04T22:26:59+08:00">2025-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-05 18:18:27" itemprop="dateModified" datetime="2025-10-05T18:18:27+08:00">2025-10-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h1><h4 id="什么是Go-Modules"><a href="#什么是Go-Modules" class="headerlink" title="什么是Go Modules?"></a>什么是Go Modules?</h4><p>Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 推荐在生产上使用。</p>
<p>Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：</p>
<ol>
<li>Go 语言长久以来的依赖管理问题。</li>
<li>“淘汰”现有的 GOPATH 的使用模式。</li>
<li>统一社区中的其它的依赖管理工具（提供迁移功能）。</li>
</ol>
<h4 id="GOPATH的工作模式"><a href="#GOPATH的工作模式" class="headerlink" title="GOPATH的工作模式"></a>GOPATH的工作模式</h4><p>Go Modoules的目的之一就是淘汰GOPATH,  那么GOPATH是个什么?</p>
<p>为什么在 Go1.11 前就使用 GOPATH，而 Go1.11 后就开始逐步建议使用 Go modules，不再推荐 GOPATH 的模式了呢？</p>
<p><strong>What is GOPATH?</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env</span><br><span class="line"></span><br><span class="line">GOPATH=<span class="string">&quot;/home/itheima/go&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们输入<code>go env</code>命令行后可以查看到 GOPATH 变量的结果，我们进入到该目录下进行查看，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── github.com</span><br><span class="line">    ├── golang.org</span><br><span class="line">    ├── google.golang.org</span><br><span class="line">    ├── gopkg.in</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>GOPATH目录下一共包含了三个子目录，分别是：</p>
<ul>
<li>bin：存储所编译生成的二进制文件。</li>
<li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。</li>
<li>src：存储所有<code>.go</code>文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以<code>$GOPATH/src/github.com/foo/bar</code>的路径进行存放。</li>
</ul>
<p>因此在使用 GOPATH 模式下，我们需要将应用代码存放在固定的<code>$GOPATH/src</code>目录下，并且如果执行<code>go get</code>来拉取外部依赖会自动下载并安装到<code>$GOPATH</code>目录下。</p>
<p><strong>GOPATH模式的弊端</strong></p>
<p>在 GOPATH 的 <code>$GOPATH/src</code> 下进行 <code>.go</code> 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式拥有一些弊端.</p>
<ul>
<li><p><strong>A. 无版本控制概念.</strong> 在执行<code>go get</code>的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。</p>
</li>
<li><p><strong>B.无法同步一致第三方版本号.</strong> 在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。</p>
</li>
<li><p><strong>C.无法指定当前项目引用的第三方版本号.</strong>  你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是<code>github.com/foo/bar</code>。</p>
</li>
</ul>
<h4 id="Go-Modules模式"><a href="#Go-Modules模式" class="headerlink" title="Go Modules模式"></a>Go Modules模式</h4><p>我们接下来用Go Modules的方式创建一个项目, 建议为了与GOPATH分开,不要将项目创建在<code>GOPATH/src</code>下.</p>
<p><strong>go mod命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>go mod init</td>
<td>生成 go.mod 文件</td>
</tr>
<tr>
<td>go mod download</td>
<td>下载 go.mod 文件中指明的所有依赖</td>
</tr>
<tr>
<td>go mod tidy</td>
<td>整理现有的依赖</td>
</tr>
<tr>
<td>go mod graph</td>
<td>查看现有的依赖结构</td>
</tr>
<tr>
<td>go mod edit</td>
<td>编辑 go.mod 文件</td>
</tr>
<tr>
<td>go mod vendor</td>
<td>导出项目所有的依赖到vendor目录</td>
</tr>
<tr>
<td>go mod verify</td>
<td>校验一个模块是否被篡改过</td>
</tr>
<tr>
<td>go mod why</td>
<td>查看为什么需要依赖某模块</td>
</tr>
</tbody></table>
<p><strong>go mod环境变量</strong></p>
<p>可以通过 <code>go env</code> 命令来进行查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span></span><br><span class="line">GO111MODULE=<span class="string">&quot;auto&quot;</span></span><br><span class="line">GOPROXY=<span class="string">&quot;https://proxy.golang.org,direct&quot;</span></span><br><span class="line">GONOPROXY=<span class="string">&quot;&quot;</span></span><br><span class="line">GOSUMDB=<span class="string">&quot;sum.golang.org&quot;</span></span><br><span class="line">GONOSUMDB=<span class="string">&quot;&quot;</span></span><br><span class="line">GOPRIVATE=<span class="string">&quot;&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>GO111MODULE</strong></p>
<p>Go语言提供了 <code>GO111MODULE</code>这个环境变量来作为 Go modules 的开关，其允许设置以下参数：</p>
<ul>
<li>auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。</li>
<li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。</li>
<li>off：禁用 Go modules，不推荐设置。</li>
</ul>
<p>可以通过来设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GO111MODULE=on</span><br></pre></td></tr></table></figure>

<p><strong>GOPROXY</strong></p>
<p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy）,其作用是用于使 Go 在后续拉取模块版本时直接通过镜像站点来快速拉取。</p>
<p>GOPROXY 的默认值是：<code>https://proxy.golang.org,direct</code></p>
<p><code>proxy.golang.org</code>国内访问不了,需要设置国内的代理.</p>
<p>如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy/,direct</span><br></pre></td></tr></table></figure>

<p><strong>direct</strong></p>
<p>而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？</p>
<p>实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision…” 的错误。</p>
<p><strong>GOSUMDB</strong></p>
<p>它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。</p>
<p>GOSUMDB 的默认值为：<code>sum.golang.org</code>，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。</p>
<p>因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 <code>goproxy.cn</code> 就能支持代理 <code>sum.golang.org</code>，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。</p>
<p>另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：</p>
<ul>
<li>格式 1：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt;</code>。</li>
<li>格式 2：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt; &lt;SUMDB_URL&gt;</code>。</li>
</ul>
<p>也可以将其设置为“off”，也就是禁止 Go 在后续操作中校验模块版本。</p>
<p><strong>GONOPROXY&#x2F;GONOSUMDB&#x2F;GOPRIVATE</strong></p>
<p>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。</p>
<p>更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。</p>
<p>而一般<strong>建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE</strong>。</p>
<p>并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOPRIVATE=<span class="string">&quot;git.example.com,github.com/eddycjy/mquote&quot;</span></span><br></pre></td></tr></table></figure>

<p>设置后，前缀为 git.xxx.com 和 github.com&#x2F;eddycjy&#x2F;mquote 的模块都会被认为是私有模块。</p>
<p>如果不想每次都重新设置，我们也可以利用通配符，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOPRIVATE=<span class="string">&quot;*.example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，<strong>需要注意的是不包括 example.com 本身</strong>。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><h4 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h4><p>协程：coroutine。也叫轻量级线程。</p>
<p>与传统的系统级线程和进程相比，协程最大的优势在于“轻量级”。可以轻松创建上万个而不会导致系统资源衰竭。而线程和进程通常很难超过1万个。这也是协程别称“轻量级线程”的原因。</p>
<p>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，<strong>多个协程分享该线程分配到的计算机资源</strong>。</p>
<p>多数语言在语法层面并不直接支持协程，而是通过库的方式支持，但用库的方式支持的功能也并不完整，比如仅仅提供协程的创建、销毁与切换等能力。如果在这样的轻量级线程中调用一个同步 IO 操作，比如网络通信、本地文件读写，都会阻塞其他的并发执行轻量级线程，从而无法真正达到轻量级线程本身期望达到的目标。</p>
<p>   在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。</p>
<p>在一次并发任务中，进程、线程、协程均可以实现。从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少。</p>
<h4 id="Go并发"><a href="#Go并发" class="headerlink" title="Go并发"></a>Go并发</h4><p>Go 在语言级别支持协程，叫goroutine。Go 语言标准库提供的所有系统调用操作（包括所有同步IO操作），都会出让CPU给其他goroutine。这让轻量级线程的切换管理不依赖于系统的线程和进程，也不需要依赖于CPU的核心数量。</p>
<p>有人把Go比作21世纪的C语言。第一是因为Go语言设计简单，第二，21世纪最重要的就是并行程序设计，而Go从语言层面就支持并发。同时，并发程序的内存管理有时候是非常复杂的，而Go语言提供了自动垃圾回收机制。</p>
<p>Go语言为并发编程而内置的上层API基于顺序通信进程模型CSP(communicating sequential processes)。这就意味着显式锁都是可以避免的，因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。</p>
<p>Go语言中的并发程序主要使用两种手段来实现。goroutine和channel。</p>
<h4 id="什么是Goroutine"><a href="#什么是Goroutine" class="headerlink" title="什么是Goroutine"></a>什么是Goroutine</h4><p>goroutin是Go语言并行设计的核心，有人称之为go程。 Goroutine从量级上看很像协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p>
<p>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争。</p>
<h4 id="创建Goroutine"><a href="#创建Goroutine" class="headerlink" title="创建Goroutine"></a>创建Goroutine</h4><p>只需在函数调⽤语句前添加 <strong>go</strong> 关键字，就可创建并发执⾏单元。开发⼈员无需了解任何执⾏细节，调度器会自动将其安排到合适的系统线程上执行。</p>
<p>在并发编程中，我们通常想将一个过程切分成几块，然后让每个goroutine各自负责一块工作，当一个程序启动时，主函数在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。而go语言的并发设计，让我们很轻松就可以达成这一目的。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span>*time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个 goroutine，启动另外一个任务</span></span><br><span class="line">    <span class="keyword">go</span> newTask()</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">//main goroutine 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;main goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main goroutine: i = 1</span><br><span class="line">new goroutine: i = 1</span><br><span class="line">main goroutine: i = 2</span><br><span class="line">new goroutine: i = 2</span><br><span class="line">new goroutine: i = 3</span><br><span class="line">main goroutine: i = 3</span><br><span class="line">main goroutine: i = 4</span><br><span class="line">new goroutine: i = 4</span><br></pre></td></tr></table></figure>



<h4 id="Goroutine特性"><a href="#Goroutine特性" class="headerlink" title="Goroutine特性"></a>Goroutine特性</h4><p><strong>主goroutine退出后，其它的工作goroutine也会自动退出：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个 goroutine，启动另外一个任务</span></span><br><span class="line">    <span class="keyword">go</span> newTask()</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main goroutine <span class="built_in">exit</span></span><br><span class="line">成功: 进程退出代码 0.</span><br></pre></td></tr></table></figure>

<h4 id="Goexit函数"><a href="#Goexit函数" class="headerlink" title="Goexit函数"></a>Goexit函数</h4><p>调用 runtime.Goexit() 将立即终止当前 goroutine 执⾏，调度器确保所有已注册 defer 延迟调用被执行。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">            runtime.Goexit() <span class="comment">// 终止当前 goroutine, import &quot;runtime&quot;</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;B&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">        &#125;()</span><br><span class="line"> </span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;()       <span class="comment">//不要忘记()</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//死循环，目的不让主goroutine结束</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.defer</span><br><span class="line">A.defer</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/02/Golang%E8%AF%AD%E6%B3%95%E6%96%B0%E5%A5%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/02/Golang%E8%AF%AD%E6%B3%95%E6%96%B0%E5%A5%87/" class="post-title-link" itemprop="url">Golang语法新奇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-02 20:13:15" itemprop="dateCreated datePublished" datetime="2025-10-02T20:13:15+08:00">2025-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-05 18:22:44" itemprop="dateModified" datetime="2025-10-05T18:22:44+08:00">2025-10-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="从一个main函数初见golang语法"><a href="#从一个main函数初见golang语法" class="headerlink" title="从一个main函数初见golang语法"></a>从一个main函数初见golang语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.<span class="built_in">println</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终端运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run test1_hello.go </span><br><span class="line">Hello Go</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>go run 表示 直接编译go语言并执行应用程序，一步完成你也可以先编译，然后再执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> build test1_hello.go </span><br><span class="line">$./test1_hello</span><br><span class="line">Hello Go</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行代码<strong>package main</strong>定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</p>
</li>
<li><p>下一行**import “fmt”**告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入&#x2F;输出）的函数。</p>
</li>
<li><p>下一行func main()是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</p>
</li>
<li><p><strong>注意：这里面go语言的语法，定义函数的时候，‘{’ 必须和函数名在同一行，不能另起一行。</strong></p>
<ul>
<li>下一行 &#x2F;<em>…</em>&#x2F; 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释。多行注释也叫块注释，均已以 &#x2F; <em>开头，并以</em> &#x2F; 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
<li>下一行fmt.Println(…)可以将字符串输出到控制台，并在最后自动增加换行字符 \n。 使用 fmt.Print(“hello, world\n”) 可以得到相同的结果。 Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</li>
</ul>
</li>
</ul>
<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>声明变量的一般形式是使用 var 关键字</p>
<p>第一种，指定变量类型，声明后若不赋值，使用默认值0。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name v_type</span><br><span class="line">v_name = value</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot; = %d\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> run test.go</span><br><span class="line">a = 0</span><br></pre></td></tr></table></figure>

<p>第二种，根据值自行判定变量类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name = value</span><br></pre></td></tr></table></figure>

<p>第三种，省略var, 注意 :&#x3D;左侧的变量不应该是已经声明过的，否则会导致编译错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v_name := value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">c : = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//第一种 使用默认值</span></span><br><span class="line">        <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;a = %d\n&quot;</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种</span></span><br><span class="line">        <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;b = %d\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种 省略后面的数据类型,自动匹配类型</span></span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">20</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;c = %d\n&quot;</span>, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四种 省略var关键字</span></span><br><span class="line">        d := <span class="number">3.14</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;d = %f\n&quot;</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>多变量的声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> ( <span class="comment">//这种分解的写法,一般用于声明全局变量</span></span><br><span class="line">        a <span class="type">int</span></span><br><span class="line">        b <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> e, f = <span class="number">123</span>, <span class="string">&quot;liudanbing&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这种不带声明格式的只能在函数体内声明</span></span><br><span class="line"><span class="comment">//g, h := 123, &quot;需要在func函数体内实现&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        g, h := <span class="number">123</span>, <span class="string">&quot;需要在func函数体内实现&quot;</span></span><br><span class="line">        fmt.Println(x, y, a, b, c, d, e, f, g, h)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能对g变量再次做初始化声明</span></span><br><span class="line">        <span class="comment">//g := 400</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        _, value := <span class="number">7</span>, <span class="number">5</span>  <span class="comment">//实际上7的赋值被废弃，变量 _  不具备读特性</span></span><br><span class="line">        <span class="comment">//fmt.Println(_) //_变量的是读不出来的</span></span><br><span class="line">        fmt.Println(value) <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><h4 id="优雅的常量-iota"><a href="#优雅的常量-iota" class="headerlink" title="优雅的常量 iota"></a>优雅的常量 iota</h4><p>有些概念有名字，并且有时候我们关注这些名字，甚至（特别）是在我们代码中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    CCVisa            = <span class="string">&quot;Visa&quot;</span></span><br><span class="line">    CCMasterCard      = <span class="string">&quot;MasterCard&quot;</span></span><br><span class="line">    CCAmericanExpress = <span class="string">&quot;American Express&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在其他时候，我们仅仅关注能把一个东西与其他的做区分。有些时候，有些时候一件事没有本质上的意义。比如，我们在一个数据库表中存储产品，我们可能不想以 string 存储他们的分类。我们不关注这个分类是怎样命名的，此外，该名字在市场上一直在变化。</p>
<p>我们仅仅关注它们是怎么彼此区分的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    CategoryBooks    = <span class="number">0</span></span><br><span class="line">    CategoryHealth   = <span class="number">1</span></span><br><span class="line">    CategoryClothing = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用 0, 1, 和 2 代替，我们也可以选择 17， 43， 和 61。这些值是任意的。</p>
<p>在 Go，常量有许多微妙之处。当用好了，可以使得代码非常优雅且易维护的。</p>
<h4 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h4><p>在 golang 中，一个方便的习惯就是使用iota标示符，它简化了常量用于增长数字的定义，给以上相同的值以准确的分类。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    CategoryBooks = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    CategoryHealth       <span class="comment">// 1</span></span><br><span class="line">    CategoryClothing     <span class="comment">// 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="iota和表达式"><a href="#iota和表达式" class="headerlink" title="iota和表达式"></a>iota和表达式</h4><p><code>iota</code>可以做更多事情，而不仅仅是 increment。更精确地说，<code>iota</code>总是用于 increment，但是它可以用于表达式，在常量中的存储结果值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Allergen <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    IgEggs Allergen = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>         <span class="comment">// 1 &lt;&lt; 0 which is 00000001</span></span><br><span class="line">    IgChocolate                         <span class="comment">// 1 &lt;&lt; 1 which is 00000010</span></span><br><span class="line">    IgNuts                              <span class="comment">// 1 &lt;&lt; 2 which is 00000100</span></span><br><span class="line">    IgStrawberries                      <span class="comment">// 1 &lt;&lt; 3 which is 00001000</span></span><br><span class="line">    IgShellfish                         <span class="comment">// 1 &lt;&lt; 4 which is 00010000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个工作是因为当你在一个<code>const</code>组中仅仅有一个标示符在一行的时候，它将使用增长的<code>iota</code>取得前面的表达式并且再运用它，。在 Go 语言的<a target="_blank" rel="noopener" href="https://legacy.gitbook.com/book/aceld/how-do-go/edit#">spec</a>中， 这就是所谓的隐性重复最后一个非空的表达式列表.</p>
<p>如果你对鸡蛋，巧克力和海鲜过敏，把这些 bits 翻转到 “on” 的位置（从左到右映射 bits）。然后你将得到一个 bit 值<code>00010011</code>，它对应十进制的 19。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(IgEggs | IgChocolate | IgShellfish)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 19</span></span><br><span class="line"><span class="keyword">type</span> ByteSize <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _           = <span class="literal">iota</span>                   <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)       <span class="comment">// 1 &lt;&lt; (10*1)</span></span><br><span class="line">    MB                                   <span class="comment">// 1 &lt;&lt; (10*2)</span></span><br><span class="line">    GB                                   <span class="comment">// 1 &lt;&lt; (10*3)</span></span><br><span class="line">    TB                                   <span class="comment">// 1 &lt;&lt; (10*4)</span></span><br><span class="line">    PB                                   <span class="comment">// 1 &lt;&lt; (10*5)</span></span><br><span class="line">    EB                                   <span class="comment">// 1 &lt;&lt; (10*6)</span></span><br><span class="line">    ZB                                   <span class="comment">// 1 &lt;&lt; (10*7)</span></span><br><span class="line">    YB                                   <span class="comment">// 1 &lt;&lt; (10*8)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当你在把两个常量定义在一行的时候会发生什么？</p>
<p>Banana 的值是什么？ 2 还是 3？ Durian 的值又是？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span></span><br><span class="line">    Cherimoya, Durian</span><br><span class="line">    Elderberry, Fig</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在下一行增长，而不是立即取得它的引用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apple: 1</span></span><br><span class="line"><span class="comment">// Banana: 2</span></span><br><span class="line"><span class="comment">// Cherimoya: 2</span></span><br><span class="line"><span class="comment">// Durian: 3</span></span><br><span class="line"><span class="comment">// Elderberry: 3</span></span><br><span class="line"><span class="comment">// Fig: 4</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h4><p>Go 函数可以返回多个值，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Mahesh&quot;</span>, <span class="string">&quot;Kumar&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kumar Mahesh</span><br></pre></td></tr></table></figure>

<h4 id="init函数与import"><a href="#init函数与import" class="headerlink" title="init函数与import"></a>init函数与import</h4><p>首先我们看一个例子：init函数：</p>
<p>init 函数可在package main中，可在其他package中，可在同一个package中出现多次。</p>
<p><strong>main函数</strong></p>
<p>main 函数只能在package main中</p>
<p><strong>执行顺序</strong></p>
<p>golang里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）。这两个函数在定义时不能有任何的参数和返回值。</p>
<p>虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数。</p>
<p>go程序会自动调用init()和main()，所以你不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。</p>
<p>程序的初始化和执行都起始于main包。</p>
<p>如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。</p>
<p>当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。</p>
<p>等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数如果使用参数，该变量可称为函数的形参。</p>
<p>形参就像定义在函数体内的局部变量。</p>
<p>调用函数，可以通过两种方式来传递参数：</p>
<p><strong>值传递</strong></p>
<p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<p>以下定义了 swap() 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   temp = x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">   x = y    <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，让我们使用值传递来调用 swap() 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 a 的值为 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 b 的值为 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 通过调用函数来交换值 */</span></span><br><span class="line">   swap(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   temp = x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">   x = y    <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">交换前 a 的值为 : 100</span><br><span class="line"></span><br><span class="line">交换前 b 的值为 : 200</span><br><span class="line"></span><br><span class="line">交换后 a 的值 : 100</span><br><span class="line"></span><br><span class="line">交换后 b 的值 : 200</span><br></pre></td></tr></table></figure>

<h4 id="引用传递-指针传递"><a href="#引用传递-指针传递" class="headerlink" title="引用传递(指针传递)"></a>引用传递(指针传递)</h4><p><strong>指针</strong></p>
<p>Go 语言中指针是很容易学习的，Go 语言中使用指针可以更简单的执行一些任务。</p>
<p>接下来让我们来一步步学习 Go 语言指针。</p>
<p>我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。</p>
<p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。</p>
<p>以下实例演示了变量在内存中地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span>   </span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;变量的地址: %x\n&quot;</span>, &amp;a  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量的地址: 20818a220</span><br></pre></td></tr></table></figure>

<p>现在我们已经了解了什么是内存地址和如何去访问它。接下来我们将具体介绍指针。</p>
<p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p>引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义交换值函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保持 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下我们通过使用引用传递来调用 swap() 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span>= <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 swap() 函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * &amp;a 指向 a 指针，a 变量的地址</span></span><br><span class="line"><span class="comment">   * &amp;b 指向 b 指针，b 变量的地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保存 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">交换前，a 的值 : 100</span><br><span class="line"></span><br><span class="line">交换前，b 的值 : 200</span><br><span class="line"></span><br><span class="line">交换后，a 的值 : 200</span><br><span class="line"></span><br><span class="line">交换后，b 的值 : 100</span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer语句被用于预定对一个函数的调用。可以把这类被defer语句调用的函数称为延迟函数。</p>
<p>defer作用：</p>
<ul>
<li>释放占用的资源</li>
<li>捕捉处理异常</li>
<li>输出日志</li>
</ul>
<p>结果</p>
<p>如果一个函数中有多个defer语句，它们会以LIFO（后进先出）的顺序执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Demo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="recover错误拦截"><a href="#recover错误拦截" class="headerlink" title="recover错误拦截"></a>recover错误拦截</h4><p>运行时panic异常一旦被引发就会导致程序崩溃。</p>
<p> Go语言提供了专用于“拦截”运行时panic的内建函数“recover”。它可以是当前的程序从运行时panic的状态中恢复并重新获得流程控制权。</p>
<p>**注意：**recover只有在defer调用的函数中有效.</p>
<p><strong>示例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func Demo(i int) &#123;</span><br><span class="line">	//定义10个元素的数组</span><br><span class="line">	var arr [10]int</span><br><span class="line">	//错误拦截要在产生错误前设置</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		//设置recover拦截错误信息</span><br><span class="line">		err := recover()</span><br><span class="line">		//产生panic异常  打印错误信息</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	//根据函数参数为数组元素赋值</span><br><span class="line">	//如果i的值超过数组下标 会报错误：数组下标越界</span><br><span class="line">	arr[i] = 10</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	Demo(10)</span><br><span class="line">	//产生错误后 程序继续</span><br><span class="line">	fmt.Println(&quot;程序继续执行...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runtime error: index out of range</span><br><span class="line">程序继续执行..</span><br></pre></td></tr></table></figure>

<p>如果程序没有异常，不会打印错误信息。</p>
<h2 id="slice和map"><a href="#slice和map" class="headerlink" title="slice和map"></a>slice和map</h2><p><strong>slice</strong></p>
<p>Go 语言切片是对数组的抽象。</p>
<p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片<code>(&quot;动态数组&quot;)</code>,与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p>
<h4 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h4><p>你可以声明一个未指定大小的数组来定义切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>默认切片不需要说明长度。</p>
<p>或使用make()函数来创建切片:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以简写为</span></span><br><span class="line"></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<p>也可以指定容量，其中capacity为可选参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, capacity)</span><br></pre></td></tr></table></figure>

<p>以上的len都是数组的长度也就是切片的长度</p>
<h4 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h4><p>直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap&#x3D;len&#x3D;3</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=[] <span class="type">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>初始化切片s,是数组arr的引用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:]</span><br></pre></td></tr></table></figure>

<p>将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex]</span><br></pre></td></tr></table></figure>

<p>缺省endIndex时将表示一直到arr的最后一个元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:]</span><br></pre></td></tr></table></figure>

<p>缺省startIndex时将表示从arr的第一个元素开始</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:endIndex]</span><br></pre></td></tr></table></figure>

<p>通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>

<h4 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h4><p>切片是可索引的，并且可以由 len() 方法获取长度。</p>
<p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>
<p>以下为具体实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len=3 <span class="built_in">cap</span>=5 slice=[0 0 0]</span><br></pre></td></tr></table></figure>

<h4 id="空-nil-切片"><a href="#空-nil-切片" class="headerlink" title="空(nil)切片"></a>空(nil)切片</h4><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line">切片是空的</span><br></pre></td></tr></table></figure>

<h4 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h4><p>可以通过设置下限及上限来设置截取切片*[lower-bound:upper-bound]*，实例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers ==&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">len=9 <span class="built_in">cap</span>=9 slice=[0 1 2 3 4 5 6 7 8]</span><br><span class="line">numbers == [0 1 2 3 4 5 6 7 8]</span><br><span class="line">numbers[1:4] == [1 2 3]</span><br><span class="line">numbers[:3] == [0 1 2]</span><br><span class="line">numbers[4:] == [4 5 6 7 8]</span><br><span class="line">len=0 <span class="built_in">cap</span>=5 slice=[]</span><br><span class="line">len=2 <span class="built_in">cap</span>=9 slice=[0 1]</span><br><span class="line">len=3 <span class="built_in">cap</span>=7 slice=[2 3 4]</span><br></pre></td></tr></table></figure>

<h4 id="append-和-copy-函数"><a href="#append-和-copy-函数" class="headerlink" title="append() 和 copy() 函数"></a>append() 和 copy() 函数</h4><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p>
<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len=0 <span class="built_in">cap</span>=0 slice=[]</span><br><span class="line">len=1 <span class="built_in">cap</span>=1 slice=[0]</span><br><span class="line">len=2 <span class="built_in">cap</span>=2 slice=[0 1]</span><br><span class="line">len=5 <span class="built_in">cap</span>=6 slice=[0 1 2 3 4]</span><br><span class="line">len=5 <span class="built_in">cap</span>=12 slice=[0 1 2 3 4]</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map和slice类似，只不过是数据结构不同，下面是map的一些声明方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//第一种声明</span></span><br><span class="line">    <span class="keyword">var</span> test1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    <span class="comment">//在使用map前，需要先make，make的作用就是给map分配数据空间</span></span><br><span class="line">    test1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>) </span><br><span class="line">    test1[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;php&quot;</span></span><br><span class="line">    test1[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;golang&quot;</span></span><br><span class="line">    test1[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">    fmt.Println(test1) <span class="comment">//map[two:golang three:java one:php]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种声明</span></span><br><span class="line">    test2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    test2[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;php&quot;</span></span><br><span class="line">    test2[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;golang&quot;</span></span><br><span class="line">    test2[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">    fmt.Println(test2) <span class="comment">//map[one:php two:golang three:java]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种声明</span></span><br><span class="line">    test3 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;one&quot;</span> : <span class="string">&quot;php&quot;</span>,</span><br><span class="line">        <span class="string">&quot;two&quot;</span> : <span class="string">&quot;golang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;three&quot;</span> : <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(test3) <span class="comment">//map[one:php two:golang three:java]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    language := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>][<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>][<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;php是世界上最美的语言&quot;</span></span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>][<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>][<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;golang抗并发非常good&quot;</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(language) <span class="comment">//map[php:map[id:1 desc:php是世界上最美的语言] golang:map[id:2 desc:golang抗并发非常good]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增删改查</span></span><br><span class="line">    <span class="comment">// val, key := language[&quot;php&quot;]  //查找是否有php这个子元素</span></span><br><span class="line">    <span class="comment">// if key &#123;</span></span><br><span class="line">    <span class="comment">//     fmt.Printf(&quot;%v&quot;, val)</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     fmt.Printf(&quot;no&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//language[&quot;php&quot;][&quot;id&quot;] = &quot;3&quot; //修改了php子元素的id值</span></span><br><span class="line">    <span class="comment">//language[&quot;php&quot;][&quot;nickname&quot;] = &quot;啪啪啪&quot; //增加php元素里的nickname值</span></span><br><span class="line">    <span class="comment">//delete(language, &quot;php&quot;)  //删除了php子元素</span></span><br><span class="line">    fmt.Println(language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>假设有两个方法，一个方法的接收者是指针类型，一个方法的接收者是值类型，那么：</p>
<ul>
<li>对于值类型的变量和指针类型的变量，这两个方法有什么区别？</li>
<li>如果这两个方法是为了实现一个接口，那么这两个方法都可以调用吗？</li>
<li>如果方法是嵌入到其他结构体中的，那么上面两种情况又是怎样的？</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> method1() &#123;</span><br><span class="line">    t.name = <span class="string">&quot;new name1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> method2() &#123;</span><br><span class="line">    t.name = <span class="string">&quot;new name2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    t := T&#123;<span class="string">&quot;old name&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;method1 调用前 &quot;</span>, t.name)</span><br><span class="line">    t.method1()</span><br><span class="line">    fmt.Println(<span class="string">&quot;method1 调用后 &quot;</span>, t.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;method2 调用前 &quot;</span>, t.name)</span><br><span class="line">    t.method2()</span><br><span class="line">    fmt.Println(<span class="string">&quot;method2 调用后 &quot;</span>, t.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">method1 调用前  old name</span><br><span class="line">method1 调用后  old name</span><br><span class="line">method2 调用前  old name</span><br><span class="line">method2 调用后  new name2</span><br></pre></td></tr></table></figure>

<p>当调用<code>t.method1()</code>时相当于<code>method1(t)</code>，实参和行参都是类型 T，可以接受。此时在<code>method1</code>()中的t只是参数t的值拷贝，所以<code>method1</code>()的修改影响不到main中的t变量。</p>
<p>当调用<code>t.method2()</code>&#x3D;&gt;<code>method2(t)</code>，这是将 T 类型传给了 *T 类型，go可能会取 t 的地址传进去：<code>method2(&amp;t)</code>。所以 <code>method1</code>() 的修改可以影响 t。</p>
<p>T 类型的变量这两个方法都是拥有的。</p>
<h4 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a>方法值和方法表达式</h4><p><strong>方法值</strong></p>
<p>我们经常选择一个方法，并且在同一个表达式里执行，比如常见的p.Distance()形式，实际上将其分成两步来执行也是可能的。p.Distance叫作“选择器”，选择器会返回一个方法”值”<code>一个将方法(Point.Distance)绑定到特定接收器变量的函数</code>。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器，只要传入函数的参数即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是给struct Point类型定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    distanceFormP := p.Distance   <span class="comment">// 方法值(相当于C语言的函数地址,函数指针)</span></span><br><span class="line">    fmt.Println(distanceFormP(q)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">    fmt.Println(p.Distance(q))    <span class="comment">// &quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际上distanceFormP 就绑定了 p接收器的方法Distance</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    distanceFormQ := q.Distance   <span class="comment">//</span></span><br><span class="line">    fmt.Println(distanceFormQ(p)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">    fmt.Println(q.Distance(p))    <span class="comment">// &quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际上distanceFormQ 就绑定了 q接收器的方法Distance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法”值”会非常实用.</p>
<p>举例来说，下面例子中的time.AfterFunc这个函数的功能是在指定的延迟时间之后来执行一个(译注：另外的)函数。且这个函数操作的是一个Rocket对象r</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rocket <span class="keyword">struct</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rocket)</span></span> Launch() &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">r := <span class="built_in">new</span>(Rocket)</span><br><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; r.Launch() &#125;)</span><br></pre></td></tr></table></figure>

<p>直接用方法”值”传入AfterFunc的话可以更为简短：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, r.Launch)</span><br></pre></td></tr></table></figure>

<p>省掉了上面那个例子里的匿名函数</p>
<p><strong>方法表达式</strong></p>
<p>和方法”值”相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器(p.Distance)语法来指定方法的接收器。</p>
<p>当T是一个类型时，方法表达式可能会写作<code>T.f</code>或者<code>(*T).f</code>，会返回一个函数”值”，这种函数会将其第一个参数用作接收器，所以可以用通常(译注：不写选择器)的方式来对其进行调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是给struct Point类型定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    distance1 := Point.Distance <span class="comment">//方法表达式, 是一个函数值(相当于C语言的函数指针)</span></span><br><span class="line">    fmt.Println(distance1(p, q))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, distance1) <span class="comment">//%T表示打出数据类型 ,这个必须放在Printf使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    distance2 := (*Point).Distance <span class="comment">//方法表达式,必须传递指针类型</span></span><br><span class="line">    distance2(&amp;p, q)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, distance2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">func(main.Point, main.Point) float64</span><br><span class="line">func(*main.Point, main.Point) float64</span><br><span class="line">// 这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()，</span><br><span class="line">// 但通过Point.Distance得到的函数需要比实际的Distance方法多一个参数，</span><br><span class="line">// 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数。</span><br><span class="line">// 看起来本书中函数和方法的区别是指有没有接收器，而不像其他语言那样是指有没有返回值。</span><br></pre></td></tr></table></figure>

<p>当你根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。你可以根据选择来调用接收器各不相同的方法。下面的例子，变量op代表Point类型的addition或者subtraction方法，Path.TranslateBy方法会为其Path数组中的每一个Point来调用对应的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是给struct Point类型定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Add(another Point) Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point&#123;p.X + another.X, p.Y + another.Y&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Sub(another Point) Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point&#123;p.X - another.X, p.Y - another.Y&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Print() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;&#123;%f, %f&#125;\n&quot;</span>, p.X, p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Point切片类型 Path</span></span><br><span class="line"><span class="keyword">type</span> Path []Point</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法的接收器 是Path类型数据, 方法的选择器是TranslateBy(Point, bool)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span></span> TranslateBy(another Point, add <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> op <span class="function"><span class="keyword">func</span><span class="params">(p, q Point)</span></span> Point <span class="comment">//定义一个 op变量 类型是方法表达式 能够接收Add,和 Sub方法</span></span><br><span class="line">        <span class="keyword">if</span> add == <span class="literal">true</span> &#123;</span><br><span class="line">                op = Point.Add <span class="comment">//给op变量赋值为Add方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                op = Point.Sub <span class="comment">//给op变量赋值为Sub方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> path &#123;</span><br><span class="line">                <span class="comment">//调用 path[i].Add(another) 或者 path[i].Sub(another)</span></span><br><span class="line">                path[i] = op(path[i], another)</span><br><span class="line">                path[i].Print()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        points := Path&#123;</span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">10</span>&#125;,</span><br><span class="line">                &#123;<span class="number">11</span>, <span class="number">11</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        anotherPoint := Point&#123;<span class="number">5</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        points.TranslateBy(anotherPoint, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        points.TranslateBy(anotherPoint, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;5.000000, 5.000000&#125;</span><br><span class="line">&#123;6.000000, 6.000000&#125;</span><br><span class="line">------------------</span><br><span class="line">&#123;10.000000, 10.000000&#125;</span><br><span class="line">&#123;11.000000, 11.000000&#125;</span><br></pre></td></tr></table></figure>

<h2 id="interface与类型断言"><a href="#interface与类型断言" class="headerlink" title="interface与类型断言"></a>interface与类型断言</h2><p>Golang的语言中提供了断言的功能。golang中的所有程序都实现了interface{}的接口，这意味着，所有的类型如string,int,int64甚至是自定义的struct类型都就此拥有了interface{}的接口，这种做法和java中的Object类型比较类似。那么在一个数据通过func funcName(interface{})的方式传进来的时候，也就意味着这个参数被自动的转为interface{}的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="type">string</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会返回</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert a (<span class="built_in">type</span> interface&#123;&#125;) to <span class="built_in">type</span> string: need <span class="built_in">type</span> assertion</span><br></pre></td></tr></table></figure>

<p>此时，意味着整个转化的过程需要类型断言。类型断言有以下几种形式：</p>
<h4 id="1）直接断言使用"><a href="#1）直接断言使用" class="headerlink" title="1）直接断言使用"></a>1）直接断言使用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Where are you,Jonny?&quot;</span>, a.(<span class="type">string</span>))</span><br></pre></td></tr></table></figure>

<p>但是如果断言失败一般会导致panic的发生。所以为了防止panic的发生，我们需要在断言前进行一定的判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := a.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<p>如果断言失败，那么ok的值将会是false,但是如果断言成功ok的值将会是true,同时value将会得到所期待的正确的值。示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value, ok := a.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;It&#x27;s not ok for type string&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;The value is &quot;</span>, value)</span><br></pre></td></tr></table></figure>

<p>完整例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func funcName(a interface&#123;&#125;) string &#123;</span></span><br><span class="line"><span class="comment">        return string(a)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        value, ok := a.(<span class="type">string</span>)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;It is not ok for type string&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;The value is &quot;</span>, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//      str := &quot;123&quot;</span></span><br><span class="line">        <span class="comment">//      funcName(str)</span></span><br><span class="line">        <span class="comment">//var a interface&#123;&#125;</span></span><br><span class="line">        <span class="comment">//var a string = &quot;123&quot;</span></span><br><span class="line">        <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">        funcName(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）配合switch使用"><a href="#2）配合switch使用" class="headerlink" title="2）配合switch使用"></a>2）配合switch使用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;unexpected type %T&quot;</span>, t)       <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者如下使用方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="type">uint</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> b, ok := x.(<span class="type">bool</span>); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> b &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;TRUE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FALSE&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s, ok := x.(<span class="type">string</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlQuoteString(s) <span class="comment">// (not shown)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T: %v&quot;</span>, x, x))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/01/Docker%E5%AE%9E%E6%88%98%E6%94%BB%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/01/Docker%E5%AE%9E%E6%88%98%E6%94%BB%E7%95%A5/" class="post-title-link" itemprop="url">Docker实战攻略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-01 20:09:40" itemprop="dateCreated datePublished" datetime="2025-10-01T20:09:40+08:00">2025-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-02 20:56:11" itemprop="dateModified" datetime="2025-10-02T20:56:11+08:00">2025-10-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Docker-核心概念"><a href="#Docker-核心概念" class="headerlink" title="Docker 核心概念"></a>Docker 核心概念</h2><p><strong>Docker 容器</strong></p>
<p>Docker 简单来说就是通过容器化技术给应用程序封装一个独立的运行环境，每个运行环境就是一个容器，运行容器的计算机被称为 <strong>宿主机</strong>。</p>
<p>与虚拟机最大的区别是：<strong>Docker 容器共享同一个系统内核，而每个虚拟机都包含一个完整的系统内核。所以 Docker 容器比虚拟机更轻量，启动速度更快。</strong></p>
<p><strong>Docker 镜像</strong></p>
<p>镜像可以理解为是一个特殊的压缩包，容器就像是通过压缩包解压（创建）出来的文件，我们可以使用同一个压缩包，解压出很多份相同的文件，也可以将这个压缩包分享给他人，得到和我们一样的文件。这里所说的 “文件”，就是上面提到的容器。</p>
<p>我们也可以通过修改容器，并生成自己特定的 Docker 镜像，并将这些镜像分享给他人，其他人可以通过镜像，创建出和我们一样的容器环境。</p>
<p><strong>Docker 仓库</strong></p>
<p>Docker 仓库就是我们用来存储、分享镜像的地方。所有人都可以把自己的镜像上传到仓库里面，其他人就可以下载镜像并使用。</p>
<p>Docker 的官方仓库是 Docker Hub (<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>)</p>
<h2 id="Docker-技术原理"><a href="#Docker-技术原理" class="headerlink" title="Docker 技术原理"></a>Docker 技术原理</h2><p>Docker 利用了 Linux 的两大原生功能，实现容器化：</p>
<ul>
<li><strong>Cgroups</strong> 用来限制和隔离进程的资源使用。可以为每个容器设定 CPU、内存、网络带宽等资源的使用上限，确保容器的内存消耗不会影响到宿主机。</li>
<li><strong>Namespaces</strong> 用于隔离进程的资源视图，使得容器只能看到自己内部的进程 ID、网络资源、文件目录，看不到宿主机的。</li>
</ul>
<p>容器本质上还是一个特殊的进程，但是当我们进入容器内部时，看起来就像是一个独立的操作系统</p>
<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><p>Docker 是基于 Linux 的容器化技术，Windows 和 Mac 需要虚拟化一个 Linux 的子系统。所以 Docker 最好的使用方式是使用 Linux 系统的宿主机。</p>
<p><strong>Linux 系统</strong></p>
<p>Linux 系统可以通过包管理器安装 Docker，例如 Redhat 系可以使用 <code>yum install docker</code> 安装。</p>
<p>Alpine Linux 可以通过 <code>apk add docker</code> 安装</p>
<p><strong>Windows 安装</strong></p>
<p>打开 “Windows 功能”, 勾选上 Virtual Machine Paftform（虚拟机平台）、适用于 Linux 的 Windows 子系统，并重启电脑。</p>
<p>管理员打开命令提示符，安装 wsl2</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br><span class="line">wsl <span class="literal">--update</span> <span class="literal">--web-download</span></span><br></pre></td></tr></table></figure>

<p>去 Docker 官网 或者 <a target="_blank" rel="noopener" href="https://github.com/tech-shrimp/docker_installer/releases">https://github.com/tech-shrimp/docker_installer/releases</a> 下载符合自己系统的 Docker Desktop 安装包，并进行安装，安装成功后 可以在终端尝试一下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Administrator&gt; docker <span class="literal">--version</span></span><br><span class="line">Docker version <span class="number">28.3</span>.<span class="number">3</span>, build <span class="number">980</span>b856</span><br></pre></td></tr></table></figure>

<p>在使用的过程中 Docker Desktop 需要一直开着，否则执行命令会出现这个报错。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker ps</span><br><span class="line">error during connect: Get <span class="string">&quot;http://%2F%2F.%2Fpipe%2FdockerDesktopLinuxEngine/v1.51/containers/json&quot;</span>: open //./pipe/dockerDesktopLinuxEngine: The system cannot find the file specified.</span><br></pre></td></tr></table></figure>

<p><strong>Mac 安装</strong></p>
<p>直接在 Docker 官网下载安装包 安装就行。</p>
<h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>Docker Pull 命令用来从仓库下载镜像。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/library/nginx:latest</span><br></pre></td></tr></table></figure>

<p>一个 Docker 镜像下载地址包含 4 部分内容：</p>
<ul>
<li><strong>docker.io:</strong> registry：仓库地址 &#x2F; 注册表，如果是 Docker 官方仓库，则可以省略这个地址。</li>
<li><strong>library:</strong> 命名空间（镜像作者），为了防止不同用户上传同一个名字的镜像 发生冲突。“library” 是 docker 官方仓库的命名空间，这个空间下的所有镜像都是由 Docker 官方维护。如果是官方的命名空间 则可以省略不写</li>
<li><strong>nginx:</strong> 镜像名</li>
<li><strong>latest:</strong> 标签名、版本号。写 “latest” 或者不写 表示获取最新版本的镜像。</li>
</ul>
<p><strong>镜像库</strong></p>
<p>repository: 镜像库，存放一个镜像的不同版本，”docker.io&#x2F;library&#x2F;nginx” 就是一个镜像库。</p>
<p>简化后的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 Docker 官方仓库的官方命名空间里面下载最新的 Nginx Docker 镜像</span></span><br><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<p>其他例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 docker.n8n.io 的私有仓库下载 n8nio 上传的 n8n 镜像</span></span><br><span class="line">docker pull docker.n8n.io/n8nio/n8n</span><br></pre></td></tr></table></figure>

<p><strong>Docker Hub</strong></p>
<p>docker 官方的镜像仓库地址为 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 可以在这个上面搜索自己需要的镜像，标有 “Docker Offcial Images” 表示 Docker 官方维护的镜像。</p>
<p>如果打不开 可以通过 <a target="_blank" rel="noopener" href="https://docker.fxxk.dedyn.io/">https://docker.fxxk.dedyn.io/</a> 镜像站来搜索镜像。</p>
<p><strong>镜像源配置</strong></p>
<p>在国内的网络环境中，如果执行 <code>docker pull</code> 可能会出现 下载失败的问题，可以参考这篇文档配置镜像站解决：<a target="_blank" rel="noopener" href="https://github.com/tech-shrimp/docker_installer?tab=readme-ov-file#2-pull%E9%95%9C%E5%83%8F">docker_installer?tab&#x3D;readme-ov-file#2-pull 镜像</a></p>
<p>（我尝试了 UP 的这几个镜像 下载还是失败了，最后用这个镜像可以正常下载，有需要的各位可以试试看）</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://docker.1ms.run&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>拉取特定架构的镜像</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull --platform=xxx nginx</span><br></pre></td></tr></table></figure>

<p>默认情况下，docker 会选择当前宿主机 CPU 架构的镜像，大部分情况下我们不需要关注这个参数。</p>
<p>Mac 目前的 M 系列 CPU 都是 arm 架构的，但在运行 AMD64 架构的容器时，会自动调用 QEMU 来模拟 x86_64 指令集，从而实现兼容 AMD64 的镜像，不过可能会存在一些兼容性问题 以及额外的性能开销。</p>
<h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>使用此命令可以查看 所有 Pull 到本地的镜像。</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [镜像标识]</span><br></pre></td></tr></table></figure>

<p>使用此命令可以删除 pull 到本地的镜像，镜像标识可以选择 镜像的 ID（image id）或者镜像的名称（repository）</p>
<h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><h3 id="创建并运行容器"><a href="#创建并运行容器" class="headerlink" title="创建并运行容器"></a>创建并运行容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [镜像标识]</span><br></pre></td></tr></table></figure>

<p>使用 run 命令 可以通过 镜像创建一个容器，并启动它。镜像标识可以是 镜像 ID 或者镜像名称。</p>
<p>例如：<code>docker run nginx</code> 就是创建一个 Nginx 容器。</p>
<p>docker pull 命令可以省略，直接使用 docker run 运行，如果 docker 发现本地没有这个镜像 则会自动拉取。</p>
<p><strong>分离模式</strong></p>
<p>默认情况下 <code>docker run</code> 创建容器后会导致当前终端挂起，不能进行其他操作，可以增加 <code>-d</code> 参数 表示容器在后台运行，不阻塞当前窗口。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker run -d nginx</span><br><span class="line">c18e9f86c0c89f2d9984dbe566349542318f8e38bb86fd17579bd9f39a8c5977</span><br></pre></td></tr></table></figure>

<p><strong>自定义容器名称</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -name kz_nginx nginx</span><br></pre></td></tr></table></figure>

<p>容器的名称和 容器 ID 的效果是等价的，但是名字更方便记忆。</p>
<p><strong>端口映射</strong></p>
<p>容器的网络和宿主机的网络是隔离的，例如运行了一个 Nginx 容器，容器内的 Nginx 监听了 80 端口。这时通过宿主机的 80 端口是无法访问到 Nginx 服务的。</p>
<p>所以需要 <code>-p {宿主机端口}:{容器端口}</code> 命令进行映射，例如 <code>-p 8080:80</code> 标识将 Nginx 容器的 80 端口映射到宿主机的 8080 端口。</p>
<p><img src="/.com//2388739180.webp" alt="410974927562106.webp"></p>
<p><strong>目录映射（绑定挂载）</strong></p>
<p>与端口映射类似的就是目录映射，将容器外和容器内的目录进行绑定，容器内对文件的修改会影响宿主机的文件夹，宿主机的修改也会影响容器内文件夹。这种目录也被称为 挂载卷，他的最大作用是数据的持久化。 当容器删除时，容器内的所有数据都会被删除，但通过挂载卷映射到宿主机的文件夹将得以保留。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 -v ./:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure>

<p>使用绑定挂载的时候，宿主机的文件会暂时覆盖掉容器内的目录。除了这种用法 还有一种叫 Docker 卷，可以在容器之间共享和重用。</p>
<p><strong>环境变量</strong></p>
<p>可以在命令行通过 <code>-e</code> 参数传递环境变量到容器内部，例如创建一个数据库应用，需要在 创建容器时，就指定数据库的账户、密码等信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 27017:27017 \</span><br><span class="line">-e MONGO_INITDB_ROOT_USERNAME=tech \</span><br><span class="line">-e MONGO_INITDB_ROOT_PASSWORD=dbkuaizi \</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure>

<p>如果不知道容器的环境变量有哪些，可以在 Docker Hub 上搜索一下，或者去 Github 上看一下 readme 文档，都有详细的描述。</p>
<p><strong>进入容器</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it alpine</span><br></pre></td></tr></table></figure>

<p>通过 <code>-it</code> 参数可以在创建一共容器时，同时进入容器内部的终端。</p>
<p><strong>退出删除</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> alpine</span><br></pre></td></tr></table></figure>

<p><code>--rm</code> 表示当退出容器时，自动删除这个容器。一般和 <code>-it</code> 命令配合使用</p>
<p><strong>容器重启策略</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart always nginx</span><br></pre></td></tr></table></figure>

<p><code>--restart</code> 参数用来表示 容器在停止时的重启策略，它有两个选项：</p>
<ul>
<li><code>always</code> 只要容器停止了，就会立即重启。包含容器因为内部错误崩溃，或者宿主机断电等场景</li>
<li><code>unless-stopped</code> ，与 <code>always</code> 类似，唯一区别是：手动停止的容器不会尝试重启了</li>
</ul>
<h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create nginx</span><br></pre></td></tr></table></figure>

<p>与 run 命令功能类似，区别在于只创建容器，不自动启动。</p>
<h3 id="容器列表"><a href="#容器列表" class="headerlink" title="容器列表"></a>容器列表</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS     NAMES</span><br><span class="line">48fe482ecff2   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   About a minute ago   Up About a minute   80/tcp    cool_hodgkin</span><br></pre></td></tr></table></figure>

<p>ps 是 Process Status (进程状态) 的缩写，也是 Linux 上的一个经典命令，用于查看进程的状态信息。这一命令也被继承到 Docker 里面了</p>
<p>这些列含义如下：</p>
<ul>
<li><code>CONTAINER ID</code> 容器 ID，每个容器在创建时会生成一个唯一的 ID</li>
<li><code>IMAGE</code> 基于那个镜像创建出来的</li>
<li><code>CREATED</code> 镜像创建时间</li>
<li><code>STATUS</code> 镜像当前状态</li>
<li><code>PORTS</code> 镜像使用端口</li>
<li><code>NAMES</code> 容器的名字，如果创建容器时没有指定名字，系统就会随机分配一个。</li>
</ul>
<p>增加 <code>-a</code> 参数可以看到所有的容器，包括正在运行的和已经停止的。</p>
<h3 id="启停容器"><a href="#启停容器" class="headerlink" title="启停容器"></a>启停容器</h3><p>每次使用 <code>docker run</code> 运行都会创建一个新的容器，如果我们需要对同一个容器进行持续的操作，可以通过 容器的启停命令来控制。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start &#123;容器标识&#125;</span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>start</code> 启停容器的时候，不需要再传递创建容器时的 端口映射、挂载卷、环境变量等参数都不需要重新写了，docker 已经自动保存了，重新启动可以按照原因运行。</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>使用 rm 命令可以删除容器，如果要删除运行中的容器 需要加 <code>-f</code> 参数强制删除。</p>
<h3 id="容器内部"><a href="#容器内部" class="headerlink" title="容器内部"></a>容器内部</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &#123;容器标识&#125; bash</span><br></pre></td></tr></table></figure>

<p>使用 <code>exec -it</code> 命令 可以进入容器，在容器内部执行 shell 命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> &#123;容器标识&#125; &#123;shell 命令&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过这种方式 在容器外部执行容器内部的命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器 alpine 中的进程信息</span></span><br><span class="line">docker <span class="built_in">exec</span> alpine ps -ef</span><br></pre></td></tr></table></figure>

<p>注意 docker 镜像为了尽可能缩小镜像体积，内部一般是一个极简的操作系统，很多系统工具、基础命令都是缺失的</p>
<h3 id="查看创建信息"><a href="#查看创建信息" class="headerlink" title="查看创建信息"></a>查看创建信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>使用这个命令可以看到容器的所有信息，输出的是一个 JSON 格式，可以直接丢给 ai 帮忙解析</p>
<h3 id="容器日志"><a href="#容器日志" class="headerlink" title="容器日志"></a>容器日志</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>这个命令可以看容器的日志，加上 <code>-f</code> 命令，可以持续输出，滚动查看。</p>
<h2 id="Docker-卷"><a href="#Docker-卷" class="headerlink" title="Docker 卷"></a>Docker 卷</h2><p>docker volume 命令用于管理 Docker 卷（volume）。卷是用于持久化数据的文件系统，可以将数据和应用程序分离，便于管理，可以在容器之间共享和重用。同时卷可以用于数据的备份和恢复。</p>
<h3 id="创建卷"><a href="#创建卷" class="headerlink" title="创建卷"></a>创建卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create &#123;卷名称&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查看卷信息"><a href="#查看卷信息" class="headerlink" title="查看卷信息"></a>查看卷信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect nginx_html</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2025-09-07T14:58:39Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/nginx_html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;nginx_html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="查看所有卷"><a href="#查看所有卷" class="headerlink" title="查看所有卷"></a>查看所有卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume list</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     nginx_html</span><br></pre></td></tr></table></figure>



<h3 id="删除卷"><a href="#删除卷" class="headerlink" title="删除卷"></a>删除卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">rm</span> nginx_html</span><br></pre></td></tr></table></figure>



<h3 id="删除未使用的卷"><a href="#删除未使用的卷" class="headerlink" title="删除未使用的卷"></a>删除未使用的卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure>



<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是一个用来 构建镜像文件的文本文件，Dockerfile 文件内包含了构建镜像所需的各种信息。</p>
<p>在项目目录下创建一个名为 <code>Dockerfile</code> 的文件，并在文件中编写镜像构成的信息。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择一个基础镜像作为运行环境</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.13</span>-slim</span><br><span class="line"><span class="comment"># 在镜像内切换一个工作目录，后续所有的操作都是基于这个目录来的</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 将项目文件拷贝到镜像的工作目录</span></span><br><span class="line"><span class="comment"># 第一个 “.” 代表当前目录，第二个 “.” 代表镜像的工作目录 </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装容器内环境需要的依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明对外提供服务的端口是哪个</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器内服务启动命令，每次启动时容器内会自动执行这个命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>,<span class="string">&quot;main.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>项目内容</strong><br>main.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;hello&quot;</span>:<span class="string">&quot;dbkuaizi&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    uvicorn.run(app,host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<p>requirements.txt</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastapi</span><br><span class="line">uvicorn</span><br></pre></td></tr></table></figure>

<p><strong>构建镜像</strong></p>
<p>Dockerfile 文件写好了，可以使用 <code>docker build</code> 构建镜像。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\demo&gt; docker build -t docker_test .</span><br><span class="line">[+] Building 65.7s (9/9) FINISHED                                                                                                                                                                                                                                  docker:desktop-linux</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                                                                                                                                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 616B                                                                                                                                                                                                                                               0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/python:3.13-slim                                                                                                                                                                                                                0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                                                                                                                                                                                                    0.0s</span><br><span class="line"> =&gt; [1/4] FROM docker.io/library/python:3.13-slim@sha256:1bca0202e953784ac2a1daf36ebbc9cbebed48afcfba12d1225aaab3793eca33                                                                                                                                                          0.0s</span><br><span class="line"> =&gt; =&gt; resolve docker.io/library/python:3.13-slim@sha256:1bca0202e953784ac2a1daf36ebbc9cbebed48afcfba12d1225aaab3793eca33                                                                                                                                                          0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                                                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 310B                                                                                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; CACHED [2/4] WORKDIR /app                                                                                                                                                                                                                                                      0.0s</span><br><span class="line"> =&gt; [3/4] COPY . .                                                                                                                                                                                                                                                                 0.1s</span><br><span class="line"> =&gt; [4/4] RUN pip install -r requirements.txt                                                                                                                                                                                                                                     63.6s</span><br><span class="line"> =&gt; exporting to image                                                                                                                                                                                                                                                             1.6s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                                                                                                                                                                                            0.9s</span><br><span class="line"> =&gt; =&gt; exporting manifest sha256:fb2f23e7feeb23365ee8cc3cd9a5a8c5d497c73538c16463e23195a6b873d7bf                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting config sha256:41ffab42f6b9d9c336023838318f252e00e15a9d5a73cc17a765dae05fdc5435                                                                                                                                                                                    0.0s</span><br><span class="line"> =&gt; =&gt; exporting attestation manifest sha256:83d850f342fee281553b7b387484f4790d4553015fb12d4cec7ac00462229a25                                                                                                                                                                      0.0s</span><br><span class="line"> =&gt; =&gt; exporting manifest list sha256:1bfb1d56ae1e7a710f2f6277d9c2a6b2b746e6710a83b1792bea01ef7bbec520                                                                                                                                                                             0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/docker_test:latest                                                                                                                                                                                                                              0.0s</span><br><span class="line"> =&gt; =&gt; unpacking to docker.io/library/docker_test:latest    </span><br></pre></td></tr></table></figure>

<p><strong>创建容器并运行</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\demo&gt; docker run -d -p 8000:8000 docker_test</span><br><span class="line">22fd617066ad0f95b1a664257f4c00a6dc1b60d9de7c894f8940f24b34859629</span><br><span class="line">PS E:\docker\demo&gt; docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED         STATUS                     PORTS                                         NAMES</span><br><span class="line">22fd617066ad   docker_test   <span class="string">&quot;python3 main.py&quot;</span>        4 seconds ago   Up 4 seconds               0.0.0.0:8000-&gt;8000/tcp, [::]:8000-&gt;8000/tcp   sharp_banach</span><br><span class="line">PS E:\docker\demo&gt; curl http://127.0.0.1:8000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StatusCode        : 200</span><br><span class="line">StatusDescription : OK</span><br><span class="line">Content           : &#123;<span class="string">&quot;hello&quot;</span>:<span class="string">&quot;dbkuaizi&quot;</span>&#125;</span><br><span class="line">RawContent        : HTTP/1.1 200 OK</span><br><span class="line">                    Content-Length: 20</span><br><span class="line">                    Content-Type: application/json</span><br><span class="line">                    Date: Tue, 09 Sep 2025 14:31:30 GMT</span><br><span class="line">                    Server: uvicorn</span><br><span class="line"></span><br><span class="line">                    &#123;<span class="string">&quot;hello&quot;</span>:<span class="string">&quot;dbkuaizi&quot;</span>&#125;</span><br><span class="line">Forms             : &#123;&#125;</span><br><span class="line">Headers           : &#123;[Content-Length, 20], [Content-Type, application/json], [Date, Tue, 09 Sep 2025 14:31:30 GMT], [Server, uvicorn]&#125;</span><br><span class="line">Images            : &#123;&#125;</span><br><span class="line">InputFields       : &#123;&#125;</span><br><span class="line">Links             : &#123;&#125;</span><br><span class="line">ParsedHtml        : System.__ComObject</span><br><span class="line">RawContentLength  : 20</span><br></pre></td></tr></table></figure>



<h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>Docker 网络 默认 Bridge（桥接模式），所有的容器都连接到这个网络中，每一个容器都分配了一个内部的 IP 地址，一般都是 172.17 开头。在这个内部子网里面，容器可以通过内部 IP 地址互相访问。</p>
<p>但<strong>容器网络和宿主机的网络是隔离的</strong>，可以使用 <code>docker network create</code> 命令创建子网，默认情况下，子网也是桥接模式的一种，然后可以指定容器加入不同的子网，同一个子网内的容器可以互相通信，而跨子网则不可以通信。</p>
<p>使用子网还有一个好处，同一个子网内的容器，可以直接使用容器名称互相访问，而不必使用内部的 IP 地址。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 名叫 network1 的子网</span></span><br><span class="line">docker network create network1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 nginx 容器 使用 network1 的子网</span></span><br><span class="line">docker run -d --network network1 nginx</span><br></pre></td></tr></table></figure>

<p><img src="/.com//3248723247.webp" alt="116224390346617.webp"></p>
<h3 id="HOST-模式"><a href="#HOST-模式" class="headerlink" title="HOST 模式"></a>HOST 模式</h3><p>host 模式下，docker 容器直接共享宿主机的网络，容器直接使用宿主机的 IP 地址，无需 <code>-p</code> 参数进行端口映射，容器内的服务直接运行在宿主机的端口上，通过宿主机的 IP 和端口就能访问到容器中服务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network host nginx</span><br></pre></td></tr></table></figure>



<h3 id="NONE-模式"><a href="#NONE-模式" class="headerlink" title="NONE 模式"></a>NONE 模式</h3><p>这个模式表示不联网</p>
<h3 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h3><p><strong>创建网络</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create network1</span><br></pre></td></tr></table></figure>

<p><strong>查看网络</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker network list</span><br><span class="line">NETWORK ID     NAME       DRIVER    SCOPE</span><br><span class="line">d30095b3bc13   bridge     bridge    <span class="built_in">local</span></span><br><span class="line">24b646446630   host       host      <span class="built_in">local</span></span><br><span class="line">a26161c3eff2   network1   bridge    <span class="built_in">local</span></span><br><span class="line">7800c9b21eb6   none       null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>除了我们创建的模式以外，还有 Docker 自带的三种模式，需要注意的是 这三个自带的网络模式是不可删除的</p>
<p><strong>删除网络</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">rm</span> network1</span><br></pre></td></tr></table></figure>



<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>有的时候 一个完整的应用可能会是很多部分组成的，例如前端、后端、数据库 以及各种附加的技术栈，这些东西应该如何容器化呢？</p>
<p>我们可以自然的想到，将这些模块都打包在一起，做成一个巨大的容器。但这样做有一个弊端，只要其中一个模块发生故障，例如 服务端内存泄露，可能会导致整个容器都崩溃挂掉。</p>
<p>并且这样做的可伸缩性差，如果想给系统做扩容，只能把整个大容器在复制一份，做不到对某个模块的精确扩容。</p>
<p>多应用的最佳实践，是把每一个模块都打包成一个独立的容器。但这样多容器 增加了很多使用成本，因为想创建多个 容器 就要多次使用 docker run ，还需要配置容器之间的网络环境，尝试管理这些容器时，一个遗漏就会导致很多问题，并且若让其他人部署项目，如果操作者对部署流程不熟悉 也会导致各种问题的发生。</p>
<p>这个时候，容器编排技术就很有用了，也就是 <strong>Docker Compose</strong>，它使用 yml 文件 管理多个容器，在这个文件中记录了容器之间时如何创建以及如何协同工作的，我们可以简单的把 Docker Compose 文件理解成一个或多个 Docker run 命令，按照特定的格式书写到一个文件中，</p>
<p>Docker Compose 格式如下：</p>
<p><img src="/.com//777337666.webp" alt="254110120740349.webp"></p>
<ul>
<li>右侧最顶级的就是 Services 元素，每个元素就对应一个 Services</li>
<li>左侧的 <code>--name</code> 在右侧就变成了 services 名</li>
<li>左侧的镜像名，在右侧写在了 <code>image:</code> 属性后面</li>
<li>左侧的 <code>-e</code> 参数，对应右边的 <code>environments</code></li>
<li>左侧的 <code>-v</code> 对应右侧的 <code>volume</code> 也就是挂载卷。</li>
<li>左侧的 <code>-p</code> 对应右边的 <code>ports</code></li>
<li>右侧的 <code>depends_on</code> 用来表示启动顺序关系，这里表示 <code>my_mongodb_express</code> 容器，依赖 <code>my_mongodb</code> 。这时 程序会先启动 mongodb 再启动荣亲</li>
</ul>
<p>左右两边唯一的区别是：左边自定义了一个子网 <code>network1</code> ，而右边没有。同一个 <code>compose</code> 文件中，定义的所有容器都会自动加入同一个子网，不用我们额外维护。</p>
<p>我们可以借助 AI 来生成 需要的 Compose 文件，而无需手动编写。</p>
<p><strong>使用 Compose</strong></p>
<p>在启动目录下创建 <code>docker-compose.yaml</code> 文件，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_mongodb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_ROOT_USERNAME:</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_ROOT_PASSWORD:</span> <span class="string">pass</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/my/datadir:/data/db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">my_mongodb_express:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo-express</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8081</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ME_CONFIG_MONGODB_SERVER:</span> <span class="string">my_mongodb</span></span><br><span class="line">      <span class="attr">ME_CONFIG_MONGODB_ADMINUSERNAME:</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">ME_CONFIG_MONGODB_ADMINPASSWORD:</span> <span class="string">pass</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_mongodb</span></span><br></pre></td></tr></table></figure>

<p><strong>创建并运行启动</strong></p>
<p>然后执行 <code>docker compose up -d</code> 运行，如果容器已经在运行了 重复执行这个命令不会有任何效果。</p>
<p>执行该命令时，会检测当前目录下 名为 <code>docker-compose.yaml</code> 或 <code>compose.yaml</code> 文件。可以通过 <code>docker compose -f tesst.yaml up -d</code> 指定 compose 文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS E:\dbkuaizi\mongodb&gt; docker compose up -d</span><br><span class="line">[+] Running 3/3</span><br><span class="line"> ✔ Network mongodb_default                 Created                                                                 0.0s</span><br><span class="line"> ✔ Container mongodb-my_mongodb-1          Started                                                                 0.6s</span><br><span class="line"> ✔ Container mongodb-my_mongodb_express-1  Started                                                                 0.7s</span><br><span class="line">PS E:\dbkuaizi\mongodb&gt;</span><br></pre></td></tr></table></figure>

<p><strong>停止并删除</strong></p>
<p><code>docker compose down</code> 命令会停止并删除容器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\mongodb&gt; docker compose down</span><br><span class="line"><span class="keyword">time</span>=<span class="string">&quot;2025-09-18T21:47:55+08:00&quot;</span> level=warning msg=<span class="string">&quot;E:\\docker\\mongodb\\docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion&quot;</span></span><br><span class="line">[+] Running 3/3</span><br><span class="line"> ✔ Container mongodb-my_mongodb_express-1  Removed                                                                 0.3s</span><br><span class="line"> ✔ Container mongodb-my_mongodb-1          Removed                                                                 0.3s</span><br><span class="line"> ✔ Network mongodb_default                 Removed                                                                 0.4s</span><br></pre></td></tr></table></figure>

<p><strong>停止不删除</strong></p>
<p><code>docker compose stop</code> 命令会停止并且不会删除容器</p>
<p><strong>启动</strong></p>
<p><code>docker compose start</code> 命令会启动停止的容器</p>
<h2 id="Docker练习地址"><a href="#Docker练习地址" class="headerlink" title="Docker练习地址"></a>Docker练习地址</h2><p><a target="_blank" rel="noopener" href="https://labs.play-with-docker.com/">labs.play-with-docker.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/01/Golang%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/01/Golang%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Golang环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-01 09:07:54 / 修改时间：12:42:42" itemprop="dateCreated datePublished" datetime="2025-10-01T09:07:54+08:00">2025-10-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Golang开发环境"><a href="#Golang开发环境" class="headerlink" title="Golang开发环境"></a>Golang开发环境</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>Go官网下载地址：<a target="_blank" rel="noopener" href="https://golang.org/dl/">https://golang.org/dl/</a></p>
<p>Go官方镜像站（推荐）：<a target="_blank" rel="noopener" href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p>
<p>根据自己系统，自行选择安装。如果是window系统 推荐下载可执行文件版,一路 Next。</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>GOROOT是安装包bin\go.exe所在的路径，GOPATH是Go工具包所在的路径。新增以下用户变量</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GOROOT = E:\Github\Go;//Go安装位置</span><br><span class="line">GOPATH = E:\GoProject;//Go项目文件位置</span><br></pre></td></tr></table></figure>

<p>右击桌面左下角【开始】–》设置 –》输入”环境”关键字，选择”编辑系统环境变量” –》环境变量 –》用户变量 –》Path –》编辑 ，新增以下内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path = %GOROOT%\bin;%GOPATH%\bin;</span><br></pre></td></tr></table></figure>

<h3 id="配置Go代理和Go包校验方式"><a href="#配置Go代理和Go包校验方式" class="headerlink" title="配置Go代理和Go包校验方式"></a>配置Go代理和Go包校验方式</h3><p>win+r打开cmd，在命令行输入以下命令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go env -w GOSUMDB=sum.golang.google.cn</span><br></pre></td></tr></table></figure>

<h3 id="验证Go环境"><a href="#验证Go环境" class="headerlink" title="验证Go环境"></a>验证Go环境</h3><p>在cmd中输入</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure>

<p>查看GOPROXY和GOSUMDB是否修改成功，成功则在windows环境下配置完成。</p>
<h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>环境配置完成，编写以下代码并运行以测试环境是否能正常使用。</p>
<p>在Go项目项目文件创建一个test文件夹，进入文件夹创建一个名为test.go的文件，并输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> fmt</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Golang!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后运行成功，可以开始编写你的Golang代码了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/25/C-%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/25/C-%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/" class="post-title-link" itemprop="url">C++的移动语义和完美转发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-25 22:36:17 / 修改时间：22:43:08" itemprop="dateCreated datePublished" datetime="2025-09-25T22:36:17+08:00">2025-09-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>C++11 引入了<strong>移动语义</strong>，利用<strong>右值引用</strong>接收临时对象或将亡值，将其内部资源（如堆内存、文件句柄等）直接搬移到新对象，而不是分配新内存并复制内容，从而极大地提升效率。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a><strong>右值引用</strong></h3><p> 右值引用的语法为T&amp;&amp;，能够绑定到纯右值或将亡值。例如： 	</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string s2 = std::<span class="built_in">move</span>(str); <span class="comment">// s2 从 str 搬移资源后，str 变为空</span></span><br></pre></td></tr></table></figure>

<p>此处，std::move(str)会将str强制转换为右值，使得s2调用<strong>移动构造函数</strong>，而非深拷贝。这时str内部的缓冲区指针直接转移给了s2，str本身被置为空状态。 	</p>
<h3 id="移动构造函数与移动赋值运算符"><a href="#移动构造函数与移动赋值运算符" class="headerlink" title="移动构造函数与移动赋值运算符"></a><strong>移动构造函数与移动赋值运算符</strong></h3><p> 如果希望自定义类型支持移动语义，需要为其提供<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Buffer</span>(<span class="type">size_t</span> n) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[n]), <span class="built_in">size</span>(n) &#123;&#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Buffer</span>(Buffer&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">data</span>(other.data), <span class="built_in">size</span>(other.size) </span><br><span class="line">    &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    Buffer&amp; <span class="keyword">operator</span>=(Buffer&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">            data = other.data;</span><br><span class="line">            size = other.size;</span><br><span class="line">            other.data = <span class="literal">nullptr</span>;</span><br><span class="line">            other.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Buffer</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当使用<strong>右值</strong>或<strong>将亡值</strong>初始化或赋值时，将直接搬移指针和大小信息，而不是重新分配内存并复制元素。 		</p>
<p>搬移完成后，原对象other会被置为空（data &#x3D; nullptr、size &#x3D; 0），保证析构时不会重复释放资源。</p>
<h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a><strong>完美转发</strong></h2><p> 在模板函数中，如果将参数直接传给另一个重载函数或工厂函数，往往会丢失原有的<strong>左值&#x2F;右值</strong>属性。例如： 	</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(param); <span class="comment">// 不能区分 param 本身是左值还是右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若param本身绑定了<strong>右值</strong>，但直接调用func(param)时会被视为<strong>左值</strong>，无法调用接受右值的重载。为了解决这一问题，需要使用<strong>完美转发</strong>，借助std::forward保留原始值类别。 	</p>
<h3 id="模板参数折叠规则与std-forward"><a href="#模板参数折叠规则与std-forward" class="headerlink" title="模板参数折叠规则与std::forward"></a><strong>模板参数折叠规则与std::forward</strong></h3><p> C++11 引入了<strong>引用折叠</strong>规则： 	</p>
<p>当模板参数T被推导为一个左值引用类型（如T&amp;）时，T&amp;&amp;会折叠为T&amp;（普通左值引用）。 		</p>
<p>当T被推导为一个非引用类型时，T&amp;&amp;为真正的右值引用。<br> 基于此，std::forward<T>(param)根据T的实际类型，返回相应的左值或右值。示例： 		</T></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(param)); <span class="comment">// 保留 param 的值类别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实参是左值，T推导为T&amp;，此时std::forward<T>(param)会将param当作左值传递。 		</T></p>
<p>如果实参是右值，T推导为普通类型T，此时std::forward<T>(param)会将param当作右值传递。</T></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// std::forward, std::move</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理左值引用: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::string&amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理右值引用: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完美转发，将 param 原封不动地传给 process</span></span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;示例&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动语义示例</span></span><br><span class="line">    std::string a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string b = std::<span class="built_in">move</span>(a);  <span class="comment">// b 从 a 搬移资源后，a 变为空</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完美转发示例</span></span><br><span class="line">    <span class="built_in">wrapper</span>(str);                   <span class="comment">// 调用左值版本</span></span><br><span class="line">    <span class="built_in">wrapper</span>(std::<span class="built_in">move</span>(str));        <span class="comment">// 调用右值版本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">a = , b = Hello</span></span><br><span class="line"><span class="comment">处理左值引用: 示例</span></span><br><span class="line"><span class="comment">处理右值引用: 示例</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 <strong>移动语义</strong> 部分，std::move(a)将a转为右值，使得b调用 <strong>移动构造函数</strong>，从a搬移内部资源；搬移后a变为空字符串。</p>
<p>在 <strong>完美转发</strong> 部分，模板wrapper使用T&amp;&amp;接收任意值类别的实参，再通过std::forward<T>(param)完美转发给重载的process函数，保留了左值或右值属性，分别调用对应的重载版本。</T></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>移动语义</strong>：通过<strong>右值引用</strong>将资源从临时对象或将亡值搬移到新对象，避免不必要的拷贝开销。</li>
<li><strong>完美转发</strong>：在模板函数中使用std::forward将参数原封不动地转发给另一个函数，保留左值或右值属性。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FII/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FII/" class="post-title-link" itemprop="url">单例模式II</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-24 21:48:09 / 修改时间：22:14:26" itemprop="dateCreated datePublished" datetime="2025-09-24T21:48:09+08:00">2025-09-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="智能指针单例实现方式"><a href="#智能指针单例实现方式" class="headerlink" title="智能指针单例实现方式"></a>智能指针单例实现方式</h2><p>我们能想到一个自动初始化资源并且自动释放的方式就是智能指针。利用智能指针自动回收资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAuto</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAuto</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">SingleAuto</span>(<span class="type">const</span> SingleAuto&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    SingleAuto&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAuto&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; <span class="title">GetInst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        single=std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">        s_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mtx; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试用代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;SingleAuto&gt; SingleAuto::single=<span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleAuto::s_mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_singleauto</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> sp1=SingleAuto::<span class="built_in">GetInst</span>();</span><br><span class="line">	<span class="keyword">auto</span> sp2=SingleAuto::<span class="built_in">GetInst</span>();</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;sp1 is:&quot;</span>&lt;&lt;sp1&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;sp2 is:&quot;</span>&lt;&lt;sp2&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板单例类实现"><a href="#模板单例类实现" class="headerlink" title="模板单例类实现"></a>模板单例类实现</h2><p>为了使用单例类更通用，比如项目中使用多个单例类，可以通过继承实现多个单例类。</p>
<p>C++11 提出了<code>call_once</code>函数，我们可以配合一个局部的静态变量<code>once_flag</code>实现线程安全的初始化。<br>多线程调用<code>call_once</code>函数时，会判断<code>once_flag</code>是否被初始化，如没被初始化则进入初始化流程，调用我们提供的初始化函数。<br>但是同一时刻只有一个线程能进入这个初始化函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&lt;T&gt;&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt;&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;T&gt; _instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">GetInst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag s_flags;</span><br><span class="line">        std::<span class="built_in">call_once</span>(s_flags,[&amp;]()&#123;</span><br><span class="line">            _instance=std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">   	~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;The Singleton is delete!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-23 21:36:48 / 修改时间：22:21:39" itemprop="dateCreated datePublished" datetime="2025-09-23T21:36:48+08:00">2025-09-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍线程安全C++单例模式的实现</p>
<h2 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h2><p>如果一个函数中定义一个局部静态变量，那么这个静态变量只会初始化一次，就是在这个函数第一次调用的时候，以后无论调用几次这个函数，函数内的静态变量不在初始化。在C++11后局部静态变量不会出现在多线程情况下初始化多个静态变量。所以我们可以利用局部静态变量这一特点实现单例模式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="type">static</span> &amp;Singleton <span class="title">GetInst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="type">static</span> Singleton single;</span><br><span class="line">    	<span class="keyword">return</span> single;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="饿汉式初始化"><a href="#饿汉式初始化" class="headerlink" title="饿汉式初始化"></a>饿汉式初始化</h2><p>在C++11之前，局部静态变量会出现线程安全问题，所以部分人推出了一种方案，就是在主线程启动后，在其他线程还没有启动前，由主线程初始化单例资源，这样其他线程获取的单例线程就不会涉及重复初始化的情况了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonHungry</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">SingletonHungry</span>()&#123;&#125;    </span><br><span class="line">    <span class="built_in">SingletonHungry</span>(<span class="type">const</span> SingletonHungry&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    SingletonHungry&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingletonHungry&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingletonHungry* <span class="title">GetInst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            single = <span class="keyword">new</span> SingletonHungry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SingletonHungry* single; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式初始化</span></span><br><span class="line">Single2Hungry* Single2Hungry::single = Single2Hungry::<span class="built_in">GetInst</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_s2</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is thread &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;inst is &quot;</span> &lt;&lt; Single2Hungry::<span class="built_in">GetInst</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_single2hungry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 addr is &quot;</span> &lt;&lt; Single2Hungry::<span class="built_in">GetInst</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2 addr is &quot;</span> &lt;&lt; Single2Hungry::<span class="built_in">GetInst</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">tid</span><span class="params">(thread_func_s2, i)</span></span>;</span><br><span class="line">        tid.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式是从使用角度规避多线程的安全问题，很多情况下我们很难从规则角度限制开发人员，所以这种方式不是很推荐。</p>
<h2 id="懒汉式初始化"><a href="#懒汉式初始化" class="headerlink" title="懒汉式初始化"></a>懒汉式初始化</h2><p>很多人觉得什么时候调用初始化是用户的权利，不应该加以限制，所以就有了懒汉式方式初始化资源，在用到时如果没有初始化单例则初始化，如果初始化了则直接使用，所以这种方式我们要加锁，防止资源被重复初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SinglePointer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">SinglePointer</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">SinglePointer</span>(<span class="type">const</span> SinglePointer&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    SinglePointer <span class="keyword">operator</span>=(<span class="type">const</span> SinglePointer&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SinglePointer* <span class="title">GetInst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        single=<span class="keyword">new</span> <span class="built_in">SinglePointer</span>();</span><br><span class="line">        s_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SinglePointer* single;</span><br><span class="line">    std::mutex s_mtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SinglePointer* SinglePointer::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SinglePointer::s_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_lazy</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is lazy thread &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;inst is &quot;</span> &lt;&lt; SinglePointer::<span class="built_in">GetInst</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_singlelazy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">tid</span><span class="params">(thread_func_lazy, i)</span></span>;</span><br><span class="line">        tid.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//何时释放new的对象？造成内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式存在一个很严重的问题，就是当多个线程都调用单例函数时，我们不确定资源是被哪个线程初始化的。<br>回收指针存在问题，存在多重释放或者不知道哪个指针释放的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/22/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E9%83%A8%E7%BD%B2%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chalice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chalice 的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/22/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E9%83%A8%E7%BD%B2%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">如何使用hexo部署你的个人博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-22 23:01:32 / 修改时间：23:05:41" itemprop="dateCreated datePublished" datetime="2025-09-22T23:01:32+08:00">2025-09-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="本地搭建"><a href="#本地搭建" class="headerlink" title="本地搭建"></a>本地搭建</h1><h2 id="1-本地搭建-Hexo-博客"><a href="#1-本地搭建-Hexo-博客" class="headerlink" title="1. 本地搭建 Hexo 博客"></a>1. 本地搭建 Hexo 博客</h2><ul>
<li>全局安装 hexo 脚手架</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<ul>
<li>新建文件夹 blog，利用脚手架生成博客工程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<ul>
<li>安装依赖，运行项目</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>之后，访问 localhost:4000 就能看到我们的博客。</p>
<p>到目前为止，我们的简易博客就搭建完成了，但是整个博客功能比较简单，我们再来了解一下其他的个性化配置。</p>
<h2 id="2-个性化配置"><a href="#2-个性化配置" class="headerlink" title="2. 个性化配置"></a>2. 个性化配置</h2><h3 id="2-1-更换主题"><a href="#2-1-更换主题" class="headerlink" title="2.1 更换主题"></a>2.1 更换主题</h3><p>Hexo 主题列表可以在官方查找 <a target="_blank" rel="noopener" href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
<p>也可以在 github 上查找 <a target="_blank" rel="noopener" href="https://github.com/search?q=hexo-theme">https://github.com/search?q=hexo-theme</a></p>
<h4 id="推荐几个优秀主题"><a href="#推荐几个优秀主题" class="headerlink" title="推荐几个优秀主题"></a>推荐几个优秀主题</h4><table>
<thead>
<tr>
<th><strong>主题</strong></th>
<th><strong>github地址</strong></th>
<th><strong>简介</strong></th>
<th>github star（25.1）</th>
</tr>
</thead>
<tbody><tr>
<td>NexT</td>
<td><a target="_blank" rel="noopener" href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></td>
<td>NexT 是 Hexo 最受欢迎的主题之一，设计简洁且功能强大</td>
<td>8.2k</td>
</tr>
<tr>
<td>Butterfly</td>
<td><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a></td>
<td>Butterfly 是一个优雅且高度可定制的主题，适合个人博客</td>
<td>7.4k</td>
</tr>
<tr>
<td>Matery</td>
<td><a target="_blank" rel="noopener" href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></td>
<td>Matery 是一个 Material Design 风格的主题，适合技术博客</td>
<td>5.3k</td>
</tr>
<tr>
<td>Yilia</td>
<td><a target="_blank" rel="noopener" href="https://github.com/litten/hexo-theme-yilia">https://github.com/litten/hexo-theme-yilia</a></td>
<td>Yilia 是一个简洁且响应式的主题，适合写作和阅读</td>
<td>8.4k</td>
</tr>
<tr>
<td>Icarus</td>
<td><a target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-icarus">https://github.com/ppoffice/hexo-theme-icarus</a></td>
<td>Icarus 是一个现代化的主题，支持多种插件和自定义配置</td>
<td>6.4k</td>
</tr>
</tbody></table>
<h4 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h4><p>以 NexT 主题为例，安装步骤如下：</p>
<ol>
<li><strong>下载主题</strong>：</li>
</ol>
<p>在博客根目录下运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>启用主题</strong>：</li>
</ol>
<p>编辑博客根目录下的 <code>_config.yml</code> 文件，修改 <code>theme</code> 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>配置主题</strong>：</li>
</ol>
<p>根据需要编辑主题配置文件（通常是 <code>themes/next/_config.yml</code>）。NexT提供了三种不同的外观，可以挑选一个自己喜欢的，然后去掉其中一个的 # 号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>重新生成并部署</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 清除缓存</span><br><span class="line">hexo clean</span><br><span class="line"># 生成主题静态文件</span><br><span class="line">hexo generate</span><br><span class="line"># 启动服务</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<h3 id="2-2-更新博客基础信息"><a href="#2-2-更新博客基础信息" class="headerlink" title="2.2 更新博客基础信息"></a>2.2 更新博客基础信息</h3><p>博客基础信息可以在根目录的 <code>_config.yml</code> 文件配置，以本博客为例，更改如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: webfem</span><br><span class="line">subtitle: &#x27;&#x27;</span><br><span class="line">description: 做有价值的博客</span><br><span class="line">keywords: 前端</span><br><span class="line">author: space</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-首页文章截断"><a href="#2-3-首页文章截断" class="headerlink" title="2.3 首页文章截断"></a>2.3 首页文章截断</h3><ol>
<li>每次写文章正文时，只需要在文章 .md 中需要截断的地方增加：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>打开 <code>/themes/next/_config.yml</code>，修改 <code>scroll_to_more</code> 这个选项设置为 <code>false</code> 。</li>
</ol>
<p><img src="https://cdn.webfem.com/webfem/cfc4f7b0-d191-11ef-aad8-11241f379ea9" alt="替换hexo的next主题.png"></p>
<h3 id="2-4-修改博客-icon"><a href="#2-4-修改博客-icon" class="headerlink" title="2.4 修改博客 icon"></a>2.4 修改博客 icon</h3><p>浏览器左上角icon修改</p>
<ol>
<li>在 <code>/source</code> 目录下新建一个名为 <code>uploads</code> 的文件夹，将头像图片（如 <code>favicon.png</code>）放入该文件夹中。</li>
<li>打开主题的配置文件（通常是 <code>/themes/next/_config.yml</code>），找到 <code>favicon</code> 相关字段，修改为你的图标文件路径。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /uploads/favicon.png  # 小图标（16x16）</span><br><span class="line">  medium: /uploads/favicon.png  # 中图标（32x32）</span><br><span class="line">  apple_touch_icon: /uploads/favicon.png  # Apple 设备图标</span><br><span class="line">  safari_pinned_tab: /uploads/favicon.png  # Safari 固定标签页图标</span><br></pre></td></tr></table></figure>

<h2 id="3-修改导航"><a href="#3-修改导航" class="headerlink" title="3. 修改导航"></a>3. 修改导航</h2><p>页面的导航需要到具体的主题目录去修改，以next为例，需要到 &#x2F;themes&#x2F;next&#x2F;_config.yml文件，将menu字段修改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br></pre></td></tr></table></figure>

<p>修改之后，我们还没有这个页面，需要手动加几个页面</p>
<h3 id="3-1-创建分类页面"><a href="#3-1-创建分类页面" class="headerlink" title="3.1 创建分类页面"></a>3.1 创建分类页面</h3><ol>
<li>使用以下命令新建一个名为 <code>categories</code> 的页面：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<ol>
<li>编辑刚创建的页面文件 <code>/source/categories/index.md</code>，将页面类型设置为 <code>categories</code>。这样，主题会自动在该页面显示所有分类。注意保留冒号后的空格。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Categories</span><br><span class="line">date: 2024-04-10 23:40:31</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="3-2-创建标签云页面"><a href="#3-2-创建标签云页面" class="headerlink" title="3.2 创建标签云页面"></a>3.2 创建标签云页面</h3><ol>
<li>使用以下命令新建一个名为 <code>tags</code> 的页面：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>编辑刚创建的页面文件，将页面类型设置为 <code>tags</code>。这样，主题会自动在该页面显示标签云。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tags</span><br><span class="line">date: 2024-04-10 23:41:25</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-创建“关于我”页面"><a href="#3-3-创建“关于我”页面" class="headerlink" title="3.3 创建“关于我”页面"></a>3.3 创建“关于我”页面</h3><ol>
<li>使用以下命令新建一个名为 <code>about</code> 的页面：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>编辑刚创建的页面文件，可以在正文部分使用 Markdown 格式写下你的个人信息。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: About</span><br><span class="line">date: 2024-04-10 23:41:56</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是我博客的内容，欢迎阅读！</span><br></pre></td></tr></table></figure>

<p>修改之后效果如下：</p>
<p><img src="https://cdn.webfem.com/webfem/69b69ae0-d192-11ef-aad8-11241f379ea9" alt="hexo-category.png"></p>
<h2 id="4-创建并编辑文章"><a href="#4-创建并编辑文章" class="headerlink" title="4. 创建并编辑文章"></a>4. 创建并编辑文章</h2><ol>
<li>在博客根目录下执行以下命令，创建一篇新文章：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;我的第一篇文章&quot;</span><br></pre></td></tr></table></figure>

<p>这会在 <code>source/_posts</code> 文件夹内生成一个 <code>.md</code> 文件。</p>
<ol>
<li>编辑该文件，修改起始字段如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章的标题</span><br><span class="line">date: 创建日期 （文件的创建日期）</span><br><span class="line">updated: 修改日期 （文件的修改日期）</span><br><span class="line">comments: true  # 是否开启评论</span><br><span class="line">tags:</span><br><span class="line">  - 标签1</span><br><span class="line">  - 标签2</span><br><span class="line">categories:</span><br><span class="line">  - 分类1</span><br><span class="line">permalink: url中的名字（文件名）</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在 <code>---</code> 下方编写正文内容，遵循 Markdown 语法规则。</p>
</li>
<li><p>生成静态资源</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>将 hello-word.md 的内容复制过来，效果如下</p>
<p><img src="https://cdn.webfem.com/webfem/643af2f0-d192-11ef-aad8-11241f379ea9" alt="hexo-blog.png"></p>
<h2 id="5-设置侧边栏"><a href="#5-设置侧边栏" class="headerlink" title="5. 设置侧边栏"></a>5. 设置侧边栏</h2><p>默认侧边栏非常简陋，需要再额外配置一下</p>
<h3 id="5-1-设置侧边栏头像"><a href="#5-1-设置侧边栏头像" class="headerlink" title="5.1 设置侧边栏头像"></a>5.1 设置侧边栏头像</h3><ol>
<li>在 <code>/source</code> 目录下新建一个名为 <code>uploads</code> 的文件夹，将头像图片（如 <code>avatar.jpg</code>）放入该文件夹中。</li>
<li>打开主题配置文件 <code>/themes/next/_config.yml</code>，找到 <code>avatar</code> 字段，并修改为以下内容：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  url: /uploads/avatar.jpg  # 头像图片路径</span><br><span class="line">  rounded: true  # 是否显示为圆形头像</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-设置侧边栏社交链接"><a href="#5-2-设置侧边栏社交链接" class="headerlink" title="5.2 设置侧边栏社交链接"></a>5.2 设置侧边栏社交链接</h3><ol>
<li>编辑站点的 <code>_config.yml</code> 文件，找到 <code>social</code> 字段，添加社交站点名称与链接地址。格式为 <code>显示名称: 链接地址 || 图标类名</code>，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Social links</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/your-user-name || fab fa-github</span><br><span class="line">  E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">  Twitter: https://x.com/your-user-name || fab fa-twitter</span><br><span class="line">  # Weibo: https://weibo.com/yourname || fab fa-weibo</span><br><span class="line">  # Google: https://plus.google.com/yourname || fab fa-google</span><br></pre></td></tr></table></figure>

<ol>
<li>打开主题配置文件 <code>/themes/next/_config.yml</code>，在 <code>social_icons</code> 字段下添加社交站点名称与对应的图标类名。<code>enable</code> 选项用于控制是否显示图标，设置为 <code>false</code> 可以隐藏图标。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">social_icons:</span><br><span class="line">  enable: true  # 是否显示图标</span><br><span class="line">  GitHub: github  # GitHub 图标</span><br><span class="line">  Twitter: twitter  # Twitter 图标</span><br></pre></td></tr></table></figure>

<h3 id="5-3-设置侧边栏友情链接"><a href="#5-3-设置侧边栏友情链接" class="headerlink" title="5.3 设置侧边栏友情链接"></a>5.3 设置侧边栏友情链接</h3><ol>
<li>打开站点的 <code>_config.yml</code> 文件，找到 <code>links</code> 字段，添加友情链接的名称与地址。格式为 <code>显示名称: 链接地址</code>，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 友情链接</span><br><span class="line">links:</span><br><span class="line">  webfem: https://webfem.com  # 示例链接</span><br><span class="line">  Hexo: https://hexo.io  # Hexo 官网</span><br><span class="line">  GitHub: https://github.com  # GitHub 官网</span><br></pre></td></tr></table></figure>

<ol>
<li>打开主题配置文件 <code>/themes/next/_config.yml</code>，找到 <code>links_icon</code> 字段，设置是否显示友情链接的图标。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">links_icon: true  # 是否显示友情链接图标</span><br></pre></td></tr></table></figure>

<ol>
<li>如果需要自定义友情链接的图标，可以在 <code>links_settings</code> 字段下添加对应的图标类名。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_settings:</span><br><span class="line">  icon: fa fa-link</span><br><span class="line">  title: 友情链接</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: block</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.webfem.com/webfem/55694f10-d192-11ef-aad8-11241f379ea9" alt="hexo-blog-total.png"></p>
<h1 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h1><ol>
<li>将本地代码发布到服务器上，推荐通过github发布</li>
<li>利用 PM2 执行如下代码即可</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start &quot;hexo server&quot; --name &quot;hexo-blog&quot;</span><br></pre></td></tr></table></figure>

<p>后续更新文章，需要在本地写完之后，再推送到服务器</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chalice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chalice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
